# Memos 分类系统完整设计方案

## 设计概述

### 核心设计原则

#### 1. 遵循现有架构模式
严格按照 memos 现有的架构模式实现，确保代码一致性和可维护性：
- 使用现有的四层架构：Database → Store → Service → API
- 遵循现有的命名规范、错误处理模式、数据流转方式
- 复用现有的基础设施：缓存、事务管理、权限验证

#### 2. 分类与标签的明确区分
- **分类(Category)**：层级组织结构，每个 memo 只能属于一个分类，私有元数据
- **标签(Tags)**：扁平特征标记，每个 memo 可以有多个标签，从内容提取，公开可见

#### 3. 隐私优先设计
分类信息作为私有元数据，类似于 `created_ts`、`updated_ts`、`visibility` 等字段：
- 只有 memo 创建者可以看到分类信息
- 公开/保护状态的 memo 不对外暴露分类信息
- API 响应中条件性返回分类字段

#### 4. 渐进式集成
- 现有标签系统完全不变
- 新增分类功能完全可选
- 现有 memo 可保持未分类状态
- 支持用户逐步采用分类功能

## 数据库设计

### 设计决策

#### 表设计遵循现有模式
严格按照 memos 现有的表设计模式：
- 使用标准字段组：`id`, `created_ts`, `updated_ts`, `row_status`
- 外键使用 `INTEGER` 类型，与 `user.id` 保持一致
- 路径字段限制最大长度 **500 字符**（基于现有项目的字符串字段通常限制）
- 颜色字段限制 **7 字符**（支持 hex 颜色格式如 #FF0000）
- 图标字段限制 **20 字符**（支持 emoji 或简短的图标名称）

#### 为什么要路径冗余存储？
基于 memos 现有的性能考虑模式（如 memo 的 payload 字段设计），选择路径冗余存储：
- **性能优先**：界面显示时无需递归查询父级路径，符合项目对查询性能的重视
- **排序友好**：直接按路径字符串排序即可得到层级结构，简化前端逻辑
- **缓存友好**：路径信息自包含，减少 JOIN 查询，符合项目的缓存设计模式

### 数据库结构

#### 新建 category 表
```sql
-- 分类表设计，严格遵循 memos 表设计规范
CREATE TABLE category (
  -- 标准主键，与其他表保持一致
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  
  -- 分类名称，限制长度防止超长输入
  name TEXT NOT NULL CHECK (length(name) <= 100 AND length(name) > 0),
  
  -- 完整路径，冗余存储提升查询性能
  path TEXT NOT NULL CHECK (length(path) <= 500 AND length(path) > 0),
  
  -- 父分类引用，NULL 表示根分类
  parent_id INTEGER REFERENCES category(id) ON DELETE CASCADE,
  
  -- 创建者，严格权限隔离
  creator_id INTEGER NOT NULL REFERENCES user(id) ON DELETE CASCADE,
  
  -- UI 展示属性
  color TEXT NOT NULL DEFAULT '#6366f1' CHECK (color REGEXP '^#[0-9A-Fa-f]{6}$'),
  icon TEXT NOT NULL DEFAULT '📁' CHECK (length(icon) <= 20),
  
  -- 标准时间戳字段，与其他表保持一致
  created_ts BIGINT NOT NULL DEFAULT (strftime('%s', 'now')),
  updated_ts BIGINT NOT NULL DEFAULT (strftime('%s', 'now')),
  
  -- 标准状态字段，支持软删除
  row_status TEXT NOT NULL DEFAULT 'NORMAL' CHECK (row_status IN ('NORMAL', 'ARCHIVED'))
);

-- 性能优化索引，基于预期查询模式
CREATE INDEX idx_category_creator_id ON category(creator_id) WHERE row_status = 'NORMAL';
CREATE INDEX idx_category_parent_id ON category(parent_id) WHERE row_status = 'NORMAL';

-- 业务约束索引，防止同一用户创建重复路径
CREATE UNIQUE INDEX idx_category_path_creator ON category(path, creator_id) WHERE row_status = 'NORMAL';

-- 防止层级过深的约束检查（最大 10 级）
-- 通过路径中的 '/' 数量控制：path REGEXP '^([^/]+/){0,9}[^/]+$'
```

#### 扩展 memo 表
```sql
-- 为现有 memo 表添加分类引用
-- 使用可空外键，保持向后兼容性
ALTER TABLE memo ADD COLUMN category_id INTEGER REFERENCES category(id) ON DELETE SET NULL;

-- 添加索引支持按分类查询，这是核心使用场景
CREATE INDEX idx_memo_category_id ON memo(category_id) WHERE row_status = 'NORMAL';
```

### 为什么这样设计？

#### 1. 级联删除策略
- **`category.creator_id → user.id`**: 用户删除时级联删除所有分类（业务合理性）
- **`category.parent_id → category.id`**: 父分类删除时级联删除子分类（数据一致性）
- **`memo.category_id → category.id`**: 分类删除时将 memo 设为未分类（数据保护）

#### 2. 约束设计理由
- **长度约束**：基于实际使用场景，防止恶意输入或误操作
- **颜色格式约束**：确保前端可正确解析和显示
- **路径唯一性**：防止同一用户创建冲突的分类结构

#### 3. 索引策略
遵循 memos 现有的索引设计模式：
- **单列索引**：支持基础查询，如按创建者列出分类
- **复合索引**：支持复杂查询，如用户 + 路径唯一性
- **条件索引**：只对有效数据建索引，提升性能

## Store 层设计

### 遵循现有模式的数据模型

#### Category 实体设计
严格按照 memos 现有实体设计模式：
```go
// store/category.go - 遵循现有命名和字段组织方式
type Category struct {
    // 系统标识符 - 与其他实体保持一致
    ID int32

    // 标准字段组 - 与 memo、user 等实体保持一致
    RowStatus RowStatus
    CreatorID int32
    CreatedTs int64
    UpdatedTs int64

    // 领域特定字段 - 按功能分组
    Name     string
    Path     string
    ParentID *int32  // 使用指针类型表示可空，与现有模式一致

    // UI 属性字段
    Color string
    Icon  string
}
```

#### 为什么不使用 UID 字段？
基于调研，memo 使用 UID 是因为需要支持用户自定义标识符。分类系统不需要这个特性，所以遵循更简单的设计，只使用系统生成的 ID。

#### FindCategory 查询模型
遵循现有的 FindXXX 设计模式：
```go
type FindCategory struct {
    // 精确匹配条件 - 指针类型表示可选
    ID         *int32
    CreatorID  *int32
    ParentID   *int32    // 特殊：nil 表示查询根分类
    RowStatus  *RowStatus

    // 分类特有查询条件
    PathPrefix *string   // 支持查询子分类树
    MaxDepth   *int      // 限制查询深度，默认无限制

    // 标准分页参数 - 与其他 Find 结构保持一致
    Limit  *int
    Offset *int
}
```

#### 为什么增加 MaxDepth 参数？
基于性能考虑，提供深度限制避免恶意深层嵌套导致的性能问题。这是对现有设计的合理扩展。

#### UpdateCategory 更新模型
```go
type UpdateCategory struct {
    ID int32  // 必需字段，用于定位记录

    // 可选更新字段 - 指针类型，nil 表示不更新
    Name      *string
    ParentID  *int32   // 支持移动分类
    Color     *string
    Icon      *string
    RowStatus *RowStatus
    UpdatedTs *int64   // 手动控制更新时间
}
```

### Store 接口扩展

#### 遵循现有接口设计模式
```go
// store/store.go - 在现有 Store 接口中添加
type Store interface {
    // ... 现有方法

    // 基础 CRUD 操作 - 遵循现有命名模式
    CreateCategory(ctx context.Context, create *Category) (*Category, error)
    ListCategories(ctx context.Context, find *FindCategory) ([]*Category, error)
    GetCategory(ctx context.Context, find *FindCategory) (*Category, error)
    UpdateCategory(ctx context.Context, update *UpdateCategory) (*Category, error)
    DeleteCategory(ctx context.Context, id int32) error

    // 分类特有的复杂操作
    GetCategoryTree(ctx context.Context, creatorID int32, rootID *int32) ([]*Category, error)
    MoveCategoryTree(ctx context.Context, categoryID int32, newParentID *int32) error
    CountMemosByCategory(ctx context.Context, categoryID int32) (int32, error)
    UncategorizeMemosByCategory(ctx context.Context, categoryID int32) error
}
```

#### 为什么需要这些特殊方法？
- **GetCategoryTree**: 一次性获取分类树，减少 N+1 查询问题
- **MoveCategoryTree**: 原子性移动分类及其子分类，保证数据一致性
- **CountMemosByCategory**: 删除前检查依赖，遵循谨慎删除原则
- **UncategorizeMemosByCategory**: 强制删除时的清理操作

### 数据库层实现要点

#### 遵循现有的错误处理模式
```go
// store/db/sqlite/category.go - 遵循现有数据库层设计
func (d *DB) CreateCategory(ctx context.Context, create *Category) (*Category, error) {
    // 1. 业务验证 - 在数据库层进行基础验证
    if create.ParentID != nil {
        if err := d.validateParentCategory(ctx, *create.ParentID, create.CreatorID); err != nil {
            return nil, err  // 直接返回错误，不包装
        }
    }

    // 2. 路径生成 - 确保路径的正确性
    path, err := d.generateCategoryPath(ctx, create.Name, create.ParentID, create.CreatorID)
    if err != nil {
        return nil, err
    }
    create.Path = path

    // 3. 数据库插入 - 使用现有的查询模式
    query := `
        INSERT INTO category (name, path, parent_id, creator_id, color, icon, created_ts, updated_ts, row_status)
        VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
    `
    
    result, err := d.db.ExecContext(ctx, query,
        create.Name, create.Path, create.ParentID, create.CreatorID,
        create.Color, create.Icon, create.CreatedTs, create.UpdatedTs, create.RowStatus,
    )
    if err != nil {
        return nil, err
    }

    // 4. 获取生成的 ID - 遵循现有模式
    id, err := result.LastInsertId()
    if err != nil {
        return nil, err
    }
    create.ID = int32(id)

    return create, nil
}
```

#### 为什么在这里进行验证？
遵循现有项目的验证策略：
- **数据库约束**：确保数据完整性（外键、唯一性等）
- **Store 层验证**：业务规则验证（父分类存在性、权限等）
- **Service 层验证**：复杂业务逻辑验证

#### 路径生成实现
```go
func (d *DB) generateCategoryPath(ctx context.Context, name string, parentID *int32, creatorID int32) (string, error) {
    // 根分类直接返回名称
    if parentID == nil {
        return name, nil
    }

    // 获取父分类路径
    parent, err := d.GetCategory(ctx, &FindCategory{
        ID:        parentID,
        CreatorID: &creatorID,  // 确保权限检查
        RowStatus: &Normal,
    })
    if err != nil {
        return "", fmt.Errorf("parent category not found: %w", err)
    }

    // 检查路径深度限制（最大 10 级）
    depth := strings.Count(parent.Path, "/") + 1
    if depth >= 10 {
        return "", errors.New("category depth limit exceeded (max 10 levels)")
    }

    return parent.Path + "/" + name, nil
}
```

#### 为什么限制 10 级深度？
基于实际使用场景和性能考虑：
- **实用性**：10 级深度足够绝大多数使用场景
- **性能**：避免过深层级导致的查询性能问题
- **用户体验**：过深的层级结构对用户不友好

### Memo 模型扩展

#### 最小化修改现有 Memo 结构
```go
// store/memo.go - 在现有 Memo 结构中添加
type Memo struct {
    // ... 现有所有字段保持不变

    // 新增分类引用 - 可空字段，保持向后兼容
    CategoryID *int32
}

// 扩展现有 FindMemo 查询条件
type FindMemo struct {
    // ... 现有所有字段保持不变

    // 新增分类查询条件
    CategoryID           *int32    // 精确分类匹配
    CategoryIDs          []int32   // 多分类匹配（IN 查询）
    IncludeSubcategories bool      // 是否包含子分类
    ExcludeCategorized   bool      // 是否排除已分类的 memo
}

// 扩展现有 UpdateMemo 结构
type UpdateMemo struct {
    // ... 现有所有字段保持不变

    // 新增分类更新字段
    CategoryID *int32  // nil 表示取消分类
}
```

#### 为什么这样扩展？
- **最小侵入**：只添加必要字段，不修改现有逻辑
- **向后兼容**：现有代码无需修改即可正常运行
- **功能完整**：支持所有必要的分类查询场景

## Protocol Buffer 设计

### 遵循现有 Proto 设计规范

#### Store Proto 定义
```protobuf
// proto/store/category.proto - 遵循现有 store proto 模式
syntax = "proto3";

package memos.store;

option go_package = "gen/store";

message Category {
  int32 id = 1;
  string name = 2;
  string path = 3;
  int32 parent_id = 4;           // 0 表示根分类，与现有 proto 的 int32 习惯一致
  int32 creator_id = 5;
  string color = 6;
  string icon = 7;
  int64 created_ts = 8;
  int64 updated_ts = 9;
  string row_status = 10;        // 枚举字符串，与现有模式一致
}
```

#### API Proto 定义
```protobuf
// proto/api/v1/category_service.proto - 遵循现有 API proto 模式
syntax = "proto3";

package memos.api.v1;

import "google/api/annotations.proto";
import "google/api/field_behavior.proto";
import "google/api/resource.proto";
import "google/protobuf/empty.proto";
import "google/protobuf/field_mask.proto";
import "google/protobuf/timestamp.proto";

// 分类服务定义 - 遵循现有服务命名和操作模式
service CategoryService {
  // 创建分类 - POST /api/v1/categories
  rpc CreateCategory(CreateCategoryRequest) returns (Category) {
    option (google.api.http) = {
      post: "/api/v1/categories"
      body: "category"
    };
    option (google.api.method_signature) = "category";
  }

  // 列出分类 - GET /api/v1/categories
  rpc ListCategories(ListCategoriesRequest) returns (ListCategoriesResponse) {
    option (google.api.http) = {get: "/api/v1/categories"};
    option (google.api.method_signature) = "";
  }

  // 获取分类 - GET /api/v1/{name=categories/*}
  rpc GetCategory(GetCategoryRequest) returns (Category) {
    option (google.api.http) = {get: "/api/v1/{name=categories/*}"};
    option (google.api.method_signature) = "name";
  }

  // 更新分类 - PATCH /api/v1/{category.name=categories/*}
  rpc UpdateCategory(UpdateCategoryRequest) returns (Category) {
    option (google.api.http) = {
      patch: "/api/v1/{category.name=categories/*}"
      body: "category"
    };
    option (google.api.method_signature) = "category,update_mask";
  }

  // 删除分类 - DELETE /api/v1/{name=categories/*}
  rpc DeleteCategory(DeleteCategoryRequest) returns (google.protobuf.Empty) {
    option (google.api.http) = {delete: "/api/v1/{name=categories/*}"};
    option (google.api.method_signature) = "name";
  }

  // 移动分类 - POST /api/v1/{name=categories/*}:move
  rpc MoveCategory(MoveCategoryRequest) returns (Category) {
    option (google.api.http) = {
      post: "/api/v1/{name=categories/*}:move"
      body: "*"
    };
    option (google.api.method_signature) = "name,parent";
  }
}

// 分类资源定义 - 遵循 Google API 资源命名规范
message Category {
  option (google.api.resource) = {
    type: "memos.api.v1/Category"
    pattern: "categories/{category}"
    name_field: "name"
    singular: "category"
    plural: "categories"
  };

  // 资源名称 - categories/{category_id}，与现有资源命名保持一致
  string name = 1 [(google.api.field_behavior) = IDENTIFIER];

  // 显示名称 - 用户输入的分类名称
  string display_name = 2 [(google.api.field_behavior) = REQUIRED];

  // 完整路径 - 只读字段，服务端生成
  string path = 3 [(google.api.field_behavior) = OUTPUT_ONLY];

  // 父分类引用 - categories/{parent_id}，可选
  optional string parent = 4 [
    (google.api.field_behavior) = OPTIONAL,
    (google.api.resource_reference) = {type: "memos.api.v1/Category"}
  ];

  // UI 属性
  string color = 5 [(google.api.field_behavior) = OPTIONAL];
  string icon = 6 [(google.api.field_behavior) = OPTIONAL];

  // 标准时间戳 - 与其他资源保持一致
  google.protobuf.Timestamp create_time = 7 [(google.api.field_behavior) = OUTPUT_ONLY];
  google.protobuf.Timestamp update_time = 8 [(google.api.field_behavior) = OUTPUT_ONLY];
}
```

#### 为什么这样设计 Proto？
1. **资源命名一致性**：`categories/{category_id}` 与 `memos/{memo_id}` 保持一致
2. **字段行为标注**：明确指示字段的输入/输出属性，便于客户端开发
3. **HTTP 映射完整**：每个 RPC 都有对应的 RESTful API 路径
4. **方法签名声明**：便于 gRPC 客户端生成代码

### 扩展 Memo Proto

#### 在现有 Memo 消息中添加分类字段
```protobuf
// proto/api/v1/memo_service.proto - 在现有 Memo 消息中添加
message Memo {
  // ... 现有所有字段保持不变

  // 分类信息 - 只有创建者可见，OUTPUT_ONLY 表示只读
  optional Category category = 25 [(google.api.field_behavior) = OUTPUT_ONLY];
}

// 在现有 ListMemosRequest 中添加分类过滤
message ListMemosRequest {
  // ... 现有所有字段保持不变

  // 分类过滤条件
  optional string category = 11 [
    (google.api.field_behavior) = OPTIONAL,
    (google.api.resource_reference) = {type: "memos.api.v1/Category"}
  ];
  
  repeated string categories = 12 [
    (google.api.field_behavior) = OPTIONAL,
    (google.api.resource_reference) = {type: "memos.api.v1/Category"}
  ];
  
  bool include_subcategories = 13 [(google.api.field_behavior) = OPTIONAL];
}

// 新增设置 memo 分类的操作
message SetMemoCategoryRequest {
  // memo 资源名称
  string name = 1 [
    (google.api.field_behavior) = REQUIRED,
    (google.api.resource_reference) = {type: "memos.api.v1/Memo"}
  ];

  // 分类资源名称，空表示取消分类
  optional string category = 2 [
    (google.api.field_behavior) = OPTIONAL,
    (google.api.resource_reference) = {type: "memos.api.v1/Category"}
  ];
}

// 在 MemoService 中添加设置分类的 RPC
service MemoService {
  // ... 现有所有 RPC 保持不变

  // 设置 memo 分类 - PATCH /api/v1/{name=memos/*}:setCategory
  rpc SetMemoCategory(SetMemoCategoryRequest) returns (google.protobuf.Empty) {
    option (google.api.http) = {
      patch: "/api/v1/{name=memos/*}:setCategory"
      body: "*"
    };
    option (google.api.method_signature) = "name,category";
  }
}
```

#### 为什么在 MemoService 中添加 SetMemoCategory？
- **职责清晰**：分类分配是对 memo 的操作，应该在 MemoService 中
- **权限一致**：复用现有的 memo 权限验证逻辑
- **事务边界**：memo 更新操作的事务边界清晰

## API Service 层设计

### CategoryService 实现策略

#### 遵循现有服务实现模式
```go
// server/router/api/v1/category_service.go
type CategoryService struct {
    apiv1pb.UnimplementedCategoryServiceServer
    Store  *store.Store
    Secret string  // 遵循现有的认证设计
}

func NewCategoryService(store *store.Store, secret string) *CategoryService {
    return &CategoryService{
        Store:  store,
        Secret: secret,
    }
}

// 遵循现有的用户认证模式
func (s *CategoryService) getCurrentUser(ctx context.Context) (*store.User, error) {
    return getCurrentUser(ctx, s.Store, s.Secret)
}
```

#### CreateCategory 实现要点
```go
func (s *CategoryService) CreateCategory(ctx context.Context, req *apiv1pb.CreateCategoryRequest) (*apiv1pb.Category, error) {
    // 1. 用户认证 - 遵循现有认证模式
    user, err := s.getCurrentUser(ctx)
    if err != nil {
        return nil, status.Errorf(codes.Unauthenticated, "failed to get current user")
    }

    // 2. 输入验证 - 遵循现有验证模式
    if req.Category == nil {
        return nil, status.Errorf(codes.InvalidArgument, "category is required")
    }
    if req.Category.DisplayName == "" {
        return nil, status.Errorf(codes.InvalidArgument, "display_name is required")
    }

    // 3. 构建 Store 模型 - 遵循现有转换模式
    storeCategory := &store.Category{
        Name:      req.Category.DisplayName,
        CreatorID: user.ID,
        Color:     req.Category.Color,
        Icon:      req.Category.Icon,
        CreatedTs: time.Now().Unix(),
        UpdatedTs: time.Now().Unix(),
        RowStatus: store.Normal,
    }

    // 4. 处理父分类引用
    if req.Category.Parent != "" {
        parentID, err := extractCategoryID(req.Category.Parent)
        if err != nil {
            return nil, status.Errorf(codes.InvalidArgument, "invalid parent category: %v", err)
        }
        
        // 验证父分类权限
        _, err = s.Store.GetCategory(ctx, &store.FindCategory{
            ID:        &parentID,
            CreatorID: &user.ID,
            RowStatus: &store.Normal,
        })
        if err != nil {
            return nil, status.Errorf(codes.NotFound, "parent category not found")
        }
        
        storeCategory.ParentID = &parentID
    }

    // 5. 创建分类 - Store 层处理复杂逻辑
    created, err := s.Store.CreateCategory(ctx, storeCategory)
    if err != nil {
        // 根据错误类型返回适当的 gRPC 错误码
        if strings.Contains(err.Error(), "UNIQUE constraint failed") {
            return nil, status.Errorf(codes.AlreadyExists, "category path already exists")
        }
        if strings.Contains(err.Error(), "depth limit exceeded") {
            return nil, status.Errorf(codes.InvalidArgument, err.Error())
        }
        return nil, status.Errorf(codes.Internal, "failed to create category")
    }

    // 6. 转换为 API 模型并返回
    return convertCategoryFromStore(created), nil
}
```

#### 为什么这样处理错误？
遵循现有项目的错误处理模式：
- **Store 层**：返回原始错误，不包装
- **Service 层**：将数据库错误转换为业务错误
- **gRPC 层**：将业务错误转换为标准 gRPC 状态码

#### ListCategories 实现 - 支持树形结构
```go
func (s *CategoryService) ListCategories(ctx context.Context, req *apiv1pb.ListCategoriesRequest) (*apiv1pb.ListCategoriesResponse, error) {
    user, err := s.getCurrentUser(ctx)
    if err != nil {
        return nil, status.Errorf(codes.Unauthenticated, "failed to get current user")
    }

    // 构建查询条件
    find := &store.FindCategory{
        CreatorID: &user.ID,
        RowStatus: &store.Normal,
    }

    // 处理分页参数 - 遵循现有分页模式
    if req.PageSize > 0 {
        limit := min(int(req.PageSize), 1000)  // 限制最大页面大小
        find.Limit = &limit
    }
    
    if req.PageToken != "" {
        offset, err := parsePageToken(req.PageToken)
        if err != nil {
            return nil, status.Errorf(codes.InvalidArgument, "invalid page token")
        }
        find.Offset = &offset
    }

    // 查询分类
    categories, err := s.Store.ListCategories(ctx, find)
    if err != nil {
        return nil, status.Errorf(codes.Internal, "failed to list categories")
    }

    // 转换并构建响应
    apiCategories := make([]*apiv1pb.Category, len(categories))
    for i, category := range categories {
        apiCategories[i] = convertCategoryFromStore(category)
    }

    response := &apiv1pb.ListCategoriesResponse{
        Categories: apiCategories,
        TotalSize:  int32(len(apiCategories)), // 简化实现，实际可能需要单独查询总数
    }

    // 生成下一页 token
    if find.Limit != nil && len(categories) >= *find.Limit {
        nextOffset := 0
        if find.Offset != nil {
            nextOffset = *find.Offset
        }
        nextOffset += len(categories)
        response.NextPageToken = generatePageToken(nextOffset)
    }

    return response, nil
}
```

### MemoService 扩展实现

#### 扩展现有 GetMemo 方法
```go
// server/router/api/v1/memo_service.go - 在现有 GetMemo 方法中添加分类信息
func (s *MemoService) GetMemo(ctx context.Context, req *apiv1pb.GetMemoRequest) (*apiv1pb.Memo, error) {
    // ... 现有的 memo 获取逻辑保持不变

    // 转换为 API 模型
    apiMemo := convertMemoFromStore(storeMemo)

    // 添加分类信息 - 只有创建者可见
    currentUser, _ := s.getCurrentUser(ctx)
    if currentUser != nil && currentUser.ID == storeMemo.CreatorID && storeMemo.CategoryID != nil {
        category, err := s.Store.GetCategory(ctx, &store.FindCategory{
            ID:        storeMemo.CategoryID,
            RowStatus: &store.Normal,
        })
        if err == nil {
            apiMemo.Category = convertCategoryFromStore(category)
        }
    }

    return apiMemo, nil
}
```

#### 实现 SetMemoCategory 方法
```go
func (s *MemoService) SetMemoCategory(ctx context.Context, req *apiv1pb.SetMemoCategoryRequest) (*emptypb.Empty, error) {
    // 1. 获取 memo 信息
    memo, err := s.getMemoByName(ctx, req.Name)
    if err != nil {
        return nil, err
    }

    // 2. 权限验证 - 只有创建者可以设置分类
    user, err := s.getCurrentUser(ctx)
    if err != nil {
        return nil, status.Errorf(codes.Unauthenticated, "failed to get current user")
    }
    if memo.CreatorID != user.ID {
        return nil, status.Errorf(codes.PermissionDenied, "only memo creator can set category")
    }

    // 3. 处理分类设置
    var categoryID *int32
    if req.Category != nil && *req.Category != "" {
        id, err := extractCategoryID(*req.Category)
        if err != nil {
            return nil, status.Errorf(codes.InvalidArgument, "invalid category: %v", err)
        }

        // 验证分类存在且属于当前用户
        category, err := s.Store.GetCategory(ctx, &store.FindCategory{
            ID:        &id,
            CreatorID: &user.ID,
            RowStatus: &store.Normal,
        })
        if err != nil {
            return nil, status.Errorf(codes.NotFound, "category not found or access denied")
        }

        categoryID = &category.ID
    }

    // 4. 更新 memo 分类
    now := time.Now().Unix()
    _, err = s.Store.UpdateMemo(ctx, &store.UpdateMemo{
        ID:         memo.ID,
        CategoryID: categoryID,
        UpdatedTs:  &now,
    })
    if err != nil {
        return nil, status.Errorf(codes.Internal, "failed to update memo category")
    }

    return &emptypb.Empty{}, nil
}
```

#### 为什么单独实现 SetMemoCategory？
- **原子操作**：分类设置是独立的业务操作
- **权限清晰**：单独的权限验证逻辑
- **审计友好**：便于记录分类变更操作
- **API 语义**：RESTful 语义更清晰

### 数据转换函数

#### Store 到 API 模型转换
```go
// 遵循现有的转换函数命名和实现模式
func convertCategoryFromStore(category *store.Category) *apiv1pb.Category {
    apiCategory := &apiv1pb.Category{
        Name:        fmt.Sprintf("categories/%d", category.ID),
        DisplayName: category.Name,
        Path:        category.Path,
        Color:       category.Color,
        Icon:        category.Icon,
        CreateTime:  timestamppb.New(time.Unix(category.CreatedTs, 0)),
        UpdateTime:  timestamppb.New(time.Unix(category.UpdatedTs, 0)),
    }

    // 处理父分类引用
    if category.ParentID != nil {
        parent := fmt.Sprintf("categories/%d", *category.ParentID)
        apiCategory.Parent = &parent
    }

    return apiCategory
}

// 资源名称解析函数
func extractCategoryID(name string) (int32, error) {
    if !strings.HasPrefix(name, "categories/") {
        return 0, errors.New("invalid category name format")
    }
    
    idStr := strings.TrimPrefix(name, "categories/")
    id, err := strconv.ParseInt(idStr, 10, 32)
    if err != nil {
        return 0, errors.New("invalid category ID")
    }
    
    return int32(id), nil
}
```

## 前端实现策略

### 状态管理设计

#### 遵循现有 Store 设计模式
```typescript
// web/src/stores/v1/category.ts - 遵循现有 store 命名规范
class CategoryState {
  // 遵循现有的状态 ID 模式，用于触发重新渲染
  stateId: string = uniqueId();
  
  // 扁平化存储分类数据，遵循现有的 Record 模式
  categoryMapByName: Record<string, Category> = {};
  
  // 当前选中的分类，用于筛选
  selectedCategoryName?: string;
  
  // 请求控制，遵循现有的 AbortController 模式
  currentRequest: AbortController | null = null;

  constructor() {
    makeAutoObservable(this);
  }

  // 遵循现有的状态更新模式
  setPartial(partial: Partial<CategoryState>) {
    Object.assign(this, partial);
  }
  
  // 获取分类列表
  get categories(): Category[] {
    return Object.values(this.categoryMapByName);
  }
  
  // 构建分类树 - 性能优化的计算属性
  get categoryTree(): CategoryTreeNode[] {
    const rootCategories = this.categories.filter(cat => !cat.parent);
    return rootCategories
      .sort((a, b) => a.displayName.localeCompare(b.displayName))
      .map(cat => this.buildCategoryNode(cat));
  }
  
  private buildCategoryNode(category: Category): CategoryTreeNode {
    const children = this.categories
      .filter(cat => cat.parent === category.name)
      .sort((a, b) => a.displayName.localeCompare(b.displayName))
      .map(child => this.buildCategoryNode(child));

    return {
      category,
      children,
      expanded: true, // 默认展开，可以扩展为持久化状态
    };
  }
}
```

#### 为什么使用扁平化存储？
遵循现有项目的设计模式：
- **更新简单**：避免深层嵌套更新的复杂性
- **查找高效**：通过 name 直接索引，O(1) 查找
- **缓存友好**：单一数据源，避免数据同步问题

#### 与 Memo Store 的集成
```typescript
// web/src/stores/v1/memo.ts - 在现有 MemoState 中添加分类筛选
class MemoState {
  // ... 现有所有字段保持不变

  // 新增分类筛选状态
  selectedCategoryName?: string;
  includeSubcategories: boolean = false;

  // 扩展现有的过滤逻辑
  get filteredMemos(): Memo[] {
    let memos = Object.values(this.memoMapByName);

    // 现有的过滤逻辑保持不变
    // ...

    // 新增分类过滤
    if (this.selectedCategoryName) {
      if (this.includeSubcategories) {
        // 获取子分类 IDs
        const categoryStore = globalStore.categoryStore;
        const subcategoryNames = this.getSubcategoryNames(this.selectedCategoryName, categoryStore);
        
        memos = memos.filter(memo => 
          memo.category && 
          (memo.category.name === this.selectedCategoryName || 
           subcategoryNames.includes(memo.category.name))
        );
      } else {
        memos = memos.filter(memo => memo.category?.name === this.selectedCategoryName);
      }
    }

    return memos;
  }

  private getSubcategoryNames(categoryName: string, categoryStore: CategoryState): string[] {
    // 递归获取子分类名称
    const category = categoryStore.categoryMapByName[categoryName];
    if (!category) return [];

    const subcategoryNames: string[] = [];
    const collectSubcategories = (catName: string) => {
      const children = categoryStore.categories.filter(cat => cat.parent === catName);
      children.forEach(child => {
        subcategoryNames.push(child.name);
        collectSubcategories(child.name);
      });
    };

    collectSubcategories(categoryName);
    return subcategoryNames;
  }
}
```

### API 调用实现

#### 遵循现有的 API 调用模式
```typescript
// web/src/stores/v1/category.ts - API 调用方法
class CategoryState {
  // ... 其他代码

  async fetchCategories() {
    // 遵循现有的请求取消模式
    if (this.currentRequest) {
      this.currentRequest.abort();
    }

    const controller = new AbortController();
    this.setPartial({ currentRequest: controller });

    try {
      const { categories } = await categoryServiceClient.listCategories(
        {},
        { signal: controller.signal }
      );

      // 更新分类映射
      const categoryMap: Record<string, Category> = {};
      for (const category of categories) {
        categoryMap[category.name] = category;
      }

      this.setPartial({
        stateId: uniqueId(),
        categoryMapByName: categoryMap,
      });
    } catch (error: any) {
      if (error.name === "AbortError") return;
      console.error("Failed to fetch categories:", error);
      throw error;
    } finally {
      if (this.currentRequest === controller) {
        this.setPartial({ currentRequest: null });
      }
    }
  }

  async createCategory(request: CreateCategoryRequest): Promise<Category> {
    const category = await categoryServiceClient.createCategory(request);
    
    // 更新本地状态
    this.setPartial({
      stateId: uniqueId(),
      categoryMapByName: {
        ...this.categoryMapByName,
        [category.name]: category,
      },
    });

    return category;
  }

  async setMemoCategory(memoName: string, categoryName?: string) {
    await memoServiceClient.setMemoCategory({
      name: memoName,
      category: categoryName,
    });

    // 触发 memo store 重新获取数据
    globalStore.memoStore.fetchMemos();
  }
}
```

### 组件实现要点

#### 分类树组件设计
```tsx
// web/src/components/CategoryTree.tsx
interface CategoryTreeProps {
  categories: CategoryTreeNode[];
  selectedCategoryName?: string;
  onCategorySelect: (categoryName?: string) => void;
  onCategoryCreate?: (parent?: Category) => void;
  onCategoryEdit?: (category: Category) => void;
  onCategoryDelete?: (category: Category) => void;
}

export const CategoryTree: React.FC<CategoryTreeProps> = ({
  categories,
  selectedCategoryName,
  onCategorySelect,
  onCategoryCreate,
  onCategoryEdit,
  onCategoryDelete,
}) => {
  return (
    <div className="category-tree space-y-1">
      {/* "全部笔记" 选项 */}
      <div 
        className={cn(
          "category-item",
          !selectedCategoryName && "category-item-selected"
        )}
        onClick={() => onCategorySelect(undefined)}
      >
        <Folder className="w-4 h-4" />
        <span>All Memos</span>
      </div>
      
      {/* 分类树节点 */}
      {categories.map(node => (
        <CategoryTreeNode
          key={node.category.name}
          node={node}
          level={0}
          selectedCategoryName={selectedCategoryName}
          onCategorySelect={onCategorySelect}
          onCategoryEdit={onCategoryEdit}
          onCategoryDelete={onCategoryDelete}
        />
      ))}
      
      {/* 创建分类按钮 */}
      {onCategoryCreate && (
        <Button
          variant="ghost"
          size="sm"
          className="category-item category-item-action"
          onClick={() => onCategoryCreate()}
        >
          <Plus className="w-4 h-4" />
          <span>New Category</span>
        </Button>
      )}
    </div>
  );
};
```

#### 为什么这样设计组件接口？
- **功能分离**：每个回调函数职责单一
- **可选属性**：支持只读和可编辑两种模式
- **一致性**：与现有组件的接口设计保持一致

#### 分类选择器组件
```tsx
// web/src/components/CategorySelector.tsx
interface CategorySelectorProps {
  value?: Category;
  categories: Category[];
  onChange: (category?: Category) => void;
  placeholder?: string;
  disabled?: boolean;
}

export const CategorySelector: React.FC<CategorySelectorProps> = ({
  value,
  categories,
  onChange,
  placeholder = "Select category...",
  disabled = false,
}) => {
  const [open, setOpen] = useState(false);

  // 构建扁平化的分类列表，保持层级信息
  const flatCategories = useMemo(() => {
    const categoryTree = buildCategoryTree(categories);
    return flattenCategoryTree(categoryTree);
  }, [categories]);

  return (
    <Popover open={open} onOpenChange={setOpen}>
      <PopoverTrigger asChild>
        <Button
          variant="outline"
          role="combobox"
          aria-expanded={open}
          disabled={disabled}
          className="justify-between"
        >
          {value ? (
            <div className="flex items-center gap-2">
              <span style={{ color: value.color }}>{value.icon}</span>
              <span className="truncate">{value.path}</span>
            </div>
          ) : (
            <span className="text-muted-foreground">{placeholder}</span>
          )}
          <ChevronsUpDown className="ml-2 h-4 w-4 shrink-0 opacity-50" />
        </Button>
      </PopoverTrigger>
      
      <PopoverContent className="w-80 p-0">
        <Command>
          <CommandInput placeholder="Search categories..." />
          <CommandEmpty>No category found.</CommandEmpty>
          <CommandGroup max-height="200px">
            {/* "无分类" 选项 */}
            <CommandItem
              onSelect={() => {
                onChange(undefined);
                setOpen(false);
              }}
            >
              <Check
                className={cn(
                  "mr-2 h-4 w-4",
                  !value ? "opacity-100" : "opacity-0"
                )}
              />
              <span className="text-muted-foreground">No category</span>
            </CommandItem>
            
            {/* 分类选项 */}
            {flatCategories.map(({ category, level }) => (
              <CommandItem
                key={category.name}
                onSelect={() => {
                  onChange(category);
                  setOpen(false);
                }}
              >
                <Check
                  className={cn(
                    "mr-2 h-4 w-4",
                    value?.name === category.name ? "opacity-100" : "opacity-0"
                  )}
                />
                <div 
                  className="flex items-center gap-2 min-w-0 flex-1"
                  style={{ paddingLeft: `${level * 12}px` }}
                >
                  <span style={{ color: category.color }}>{category.icon}</span>
                  <span className="truncate">{category.displayName}</span>
                </div>
              </CommandItem>
            ))}
          </CommandGroup>
        </Command>
      </PopoverContent>
    </Popover>
  );
};
```

### 隐私保护的实现

#### 条件渲染策略
```tsx
// web/src/components/MemoCard.tsx - 扩展现有 MemoCard 组件
export const MemoCard: React.FC<MemoCardProps> = ({ memo }) => {
  const { userStore } = useGlobalStore();
  
  // 检查是否为创建者 - 遵循现有的权限检查模式
  const isCreator = userStore.currentUser?.name === memo.creator;
  const showPrivateMetadata = isCreator;

  return (
    <Card className="memo-card">
      {/* 分类信息 - 只有创建者可见 */}
      {showPrivateMetadata && memo.category && (
        <div className="memo-category-breadcrumb">
          <CategoryBreadcrumb category={memo.category} />
        </div>
      )}

      {/* memo 内容 - 现有逻辑保持不变 */}
      <div className="memo-content">
        <MemoContent content={memo.content} />
      </div>

      {/* 元信息区域 */}
      <div className="memo-meta">
        <div className="memo-timestamps">
          <time>{formatDateTime(memo.createTime)}</time>
          {showPrivateMetadata && memo.updateTime && (
            <span className="text-muted-foreground text-sm">
              · Updated {formatRelativeTime(memo.updateTime)}
            </span>
          )}
        </div>

        {/* 标签 - 始终可见 */}
        {memo.tags.length > 0 && (
          <div className="memo-tags">
            {memo.tags.map(tag => (
              <Badge key={tag} variant="secondary">#{tag}</Badge>
            ))}
          </div>
        )}

        {/* 私有元数据 - 只有创建者可见 */}
        {showPrivateMetadata && (
          <div className="memo-private-meta">
            <VisibilityBadge visibility={memo.visibility} />
          </div>
        )}
      </div>
    </Card>
  );
};
```

#### 为什么这样实现隐私保护？
- **一致性检查**：使用统一的 `isCreator` 逻辑
- **默认隐藏**：默认不显示分类信息，只在确认权限后显示
- **清晰分离**：私有元数据和公共信息明确分离

## 数据库迁移实现

### 遵循现有迁移模式

#### 迁移文件组织
```
store/migration/
├── sqlite/
│   └── 0.23/  # 假设当前版本是 0.22
│       ├── 00__category_table.sql
│       ├── 01__memo_category_field.sql
│       └── 02__category_indexes.sql
├── postgres/
│   └── 0.23/
│       ├── 00__category_table.sql
│       ├── 01__memo_category_field.sql
│       └── 02__category_indexes.sql
└── mysql/
    └── 0.23/
        ├── 00__category_table.sql
        ├── 01__memo_category_field.sql
        └── 02__category_indexes.sql
```

#### SQLite 迁移脚本
```sql
-- store/migration/sqlite/0.23/00__category_table.sql
CREATE TABLE category (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  name TEXT NOT NULL CHECK (length(name) <= 100 AND length(name) > 0),
  path TEXT NOT NULL CHECK (length(path) <= 500 AND length(path) > 0),
  parent_id INTEGER REFERENCES category(id) ON DELETE CASCADE,
  creator_id INTEGER NOT NULL REFERENCES user(id) ON DELETE CASCADE,
  color TEXT NOT NULL DEFAULT '#6366f1' CHECK (color REGEXP '^#[0-9A-Fa-f]{6}$'),
  icon TEXT NOT NULL DEFAULT '📁' CHECK (length(icon) <= 20),
  created_ts BIGINT NOT NULL DEFAULT (strftime('%s', 'now')),
  updated_ts BIGINT NOT NULL DEFAULT (strftime('%s', 'now')),
  row_status TEXT NOT NULL DEFAULT 'NORMAL' CHECK (row_status IN ('NORMAL', 'ARCHIVED'))
);

-- store/migration/sqlite/0.23/01__memo_category_field.sql
ALTER TABLE memo ADD COLUMN category_id INTEGER REFERENCES category(id) ON DELETE SET NULL;

-- store/migration/sqlite/0.23/02__category_indexes.sql
CREATE INDEX idx_category_creator_id ON category(creator_id) WHERE row_status = 'NORMAL';
CREATE INDEX idx_category_parent_id ON category(parent_id) WHERE row_status = 'NORMAL';
CREATE UNIQUE INDEX idx_category_path_creator ON category(path, creator_id) WHERE row_status = 'NORMAL';
CREATE INDEX idx_memo_category_id ON memo(category_id) WHERE row_status = 'NORMAL';
```

#### 为什么分成多个文件？
遵循现有项目的最佳实践：
- **原子操作**：每个文件代表一个逻辑单元
- **容错性**：单个操作失败不影响其他操作
- **可读性**：文件名清楚表明操作内容
- **版本控制**：便于跟踪特定变更

#### PostgreSQL 适配
```sql
-- store/migration/postgres/0.23/00__category_table.sql
CREATE TABLE category (
  id SERIAL PRIMARY KEY,
  name VARCHAR(100) NOT NULL CHECK (length(name) > 0),
  path VARCHAR(500) NOT NULL CHECK (length(path) > 0),
  parent_id INTEGER REFERENCES category(id) ON DELETE CASCADE,
  creator_id INTEGER NOT NULL REFERENCES "user"(id) ON DELETE CASCADE,
  color VARCHAR(7) NOT NULL DEFAULT '#6366f1' CHECK (color ~ '^#[0-9A-Fa-f]{6}$'),
  icon VARCHAR(20) NOT NULL DEFAULT '📁',
  created_ts BIGINT NOT NULL DEFAULT EXTRACT(epoch FROM NOW()),
  updated_ts BIGINT NOT NULL DEFAULT EXTRACT(epoch FROM NOW()),
  row_status VARCHAR(20) NOT NULL DEFAULT 'NORMAL' CHECK (row_status IN ('NORMAL', 'ARCHIVED'))
);
```

#### 数据库差异处理要点
- **主键生成**：SQLite 使用 `AUTOINCREMENT`，PostgreSQL 使用 `SERIAL`
- **正则表达式**：SQLite 使用 `REGEXP`，PostgreSQL 使用 `~`
- **时间戳**：不同数据库的时间函数差异
- **关键字转义**：PostgreSQL 的 `user` 需要引号

## 测试策略

### 遵循现有测试模式

#### Store 层测试
```go
// store/test/category_test.go
func TestCategoryStore(t *testing.T) {
    ctx := context.Background()
    ts := NewTestingStore(ctx, t)
    
    // 创建测试用户 - 遵循现有测试数据创建模式
    user, err := createTestingHostUser(ctx, ts)
    require.NoError(t, err)

    t.Run("CreateCategory", func(t *testing.T) {
        category := &store.Category{
            Name:      "Work",
            CreatorID: user.ID,
            Color:     "#ff0000",
            Icon:      "💼",
            CreatedTs: time.Now().Unix(),
            UpdatedTs: time.Now().Unix(),
            RowStatus: store.Normal,
        }

        created, err := ts.CreateCategory(ctx, category)
        require.NoError(t, err)
        require.NotZero(t, created.ID)
        require.Equal(t, "Work", created.Name)
        require.Equal(t, "Work", created.Path) // 根分类路径等于名称
        require.Nil(t, created.ParentID)
    })

    t.Run("CreateSubcategory", func(t *testing.T) {
        // 先创建父分类
        parent := &store.Category{
            Name:      "Projects",
            CreatorID: user.ID,
            CreatedTs: time.Now().Unix(),
            UpdatedTs: time.Now().Unix(),
            RowStatus: store.Normal,
        }
        parentCreated, err := ts.CreateCategory(ctx, parent)
        require.NoError(t, err)

        // 创建子分类
        child := &store.Category{
            Name:      "Mobile App",
            ParentID:  &parentCreated.ID,
            CreatorID: user.ID,
            CreatedTs: time.Now().Unix(),
            UpdatedTs: time.Now().Unix(),
            RowStatus: store.Normal,
        }
        childCreated, err := ts.CreateCategory(ctx, child)
        require.NoError(t, err)
        require.Equal(t, "Projects/Mobile App", childCreated.Path)
    })

    t.Run("PreventCircularReference", func(t *testing.T) {
        // 测试循环引用检测逻辑
        // ... 测试实现
    })
}
```

#### API 层测试
```go
// server/router/api/v1/test/category_service_test.go
func TestCategoryService(t *testing.T) {
    ctx := context.Background()
    s := NewTestService(ctx, t)
    
    // 创建测试用户和认证上下文
    user, err := createTestingAdminUser(ctx, s.Store)
    require.NoError(t, err)
    
    ctx = metadata.AppendToOutgoingContext(ctx, "authorization", "Bearer "+generateAccessToken(user.Username, user.ID, time.Hour, s.Secret))

    t.Run("CreateCategory", func(t *testing.T) {
        req := &apiv1pb.CreateCategoryRequest{
            Category: &apiv1pb.Category{
                DisplayName: "Work",
                Color:       "#ff0000",
                Icon:        "💼",
            },
        }

        category, err := s.CategoryService.CreateCategory(ctx, req)
        require.NoError(t, err)
        require.True(t, strings.HasPrefix(category.Name, "categories/"))
        require.Equal(t, "Work", category.DisplayName)
        require.Equal(t, "Work", category.Path)
    })

    t.Run("RequireAuthentication", func(t *testing.T) {
        // 测试未认证请求
        unauthCtx := context.Background()
        req := &apiv1pb.CreateCategoryRequest{
            Category: &apiv1pb.Category{DisplayName: "Test"},
        }

        _, err := s.CategoryService.CreateCategory(unauthCtx, req)
        require.Error(t, err)
        require.Equal(t, codes.Unauthenticated, status.Code(err))
    })
}
```

#### 为什么这样设计测试？
- **数据隔离**：每个测试使用独立的数据库实例
- **认证测试**：验证权限控制的正确性
- **边界测试**：测试各种边界条件和错误场景
- **一致性**：与现有测试的风格和结构保持一致

## 性能和扩展性考虑

### 性能优化策略

#### 1. 查询优化限制
基于实际使用场景设置合理限制：
- **分类深度限制**：最大 10 级，防止恶意深度嵌套
- **分类数量限制**：单用户最大 1000 个分类
- **路径长度限制**：最大 500 字符，防止过长路径
- **批量操作限制**：单次最大操作 100 个分类

#### 2. 缓存策略
```go
// store/cache.go - 扩展现有缓存系统
type CategoryCache struct {
    // 用户分类树缓存，TTL 30分钟
    userTreeCache *cache.Cache[string, []*Category]
    
    // 分类路径缓存，TTL 1小时
    pathCache *cache.Cache[int32, string]
}

func (c *CategoryCache) GetUserCategoryTree(userID int32) ([]*Category, bool) {
    key := fmt.Sprintf("user:%d:tree", userID)
    return c.userTreeCache.Get(key)
}

func (c *CategoryCache) InvalidateUserCache(userID int32) {
    key := fmt.Sprintf("user:%d:tree", userID)
    c.userTreeCache.Delete(key)
}
```

#### 为什么这样设计缓存？
- **用户隔离**：每个用户的分类树独立缓存
- **适度 TTL**：平衡数据新鲜度和性能
- **选择性失效**：只在必要时清理相关缓存

#### 3. 数据库优化
```sql
-- 基于查询模式优化的索引策略
-- 频繁查询：按用户列出分类
CREATE INDEX idx_category_creator_status ON category(creator_id, row_status);

-- 中等频率：构建分类树
CREATE INDEX idx_category_parent_creator ON category(parent_id, creator_id) WHERE row_status = 'NORMAL';

-- 低频查询：按路径查找分类（主要用于去重）
CREATE INDEX idx_category_path_hash ON category(substr(path, 1, 100)) WHERE row_status = 'NORMAL';
```

### 扩展性设计

#### 1. 分类属性扩展
预留扩展字段，支持未来功能：
```go
// 未来可能的扩展字段
type Category struct {
    // ... 现有字段
    
    // 扩展属性（存储 JSON）
    Metadata map[string]interface{} `json:"metadata,omitempty"`
    
    // 排序权重
    SortOrder *int32 `json:"sort_order,omitempty"`
    
    // 描述信息
    Description *string `json:"description,omitempty"`
}
```

#### 2. 权限系统扩展
为未来的权限细化预留接口：
```go
// 权限检查接口，可扩展为复杂权限系统
type CategoryPermissionChecker interface {
    CanRead(ctx context.Context, userID int32, categoryID int32) (bool, error)
    CanWrite(ctx context.Context, userID int32, categoryID int32) (bool, error)
    CanDelete(ctx context.Context, userID int32, categoryID int32) (bool, error)
}
```

#### 3. 多租户支持
虽然当前是单租户，但设计上支持未来的多租户扩展：
- **工作空间隔离**：通过 `creator_id` 天然实现用户数据隔离
- **资源命名**：支持扩展为 `workspaces/{workspace}/categories/{category}`
- **权限边界**：用户只能访问自己创建的分类

## 实施计划

### 第一阶段：核心功能（2-3 周）
1. **数据库层**：创建迁移脚本，建立基础表结构
2. **Store 层**：实现基础 CRUD 操作和查询逻辑
3. **Proto 定义**：定义 API 接口和数据模型
4. **基础测试**：Store 层和数据库层测试

### 第二阶段：API 集成（2-3 周）
1. **CategoryService**：实现完整的分类管理 API
2. **MemoService 扩展**：实现分类分配和查询功能
3. **权限验证**：确保分类隐私保护
4. **API 测试**：端到端 API 测试

### 第三阶段：前端实现（3-4 周）
1. **状态管理**：实现分类 Store 和 API 调用
2. **基础组件**：分类树、分类选择器等
3. **集成界面**：将分类功能集成到现有界面
4. **用户体验**：响应式设计和交互优化

### 第四阶段：完善和优化（1-2 周）
1. **性能优化**：缓存策略和查询优化
2. **错误处理**：完善错误场景处理
3. **文档更新**：API 文档和用户文档
4. **发布准备**：测试和部署脚本

### 风险控制措施
1. **渐进发布**：通过功能开关控制功能上线
2. **向后兼容**：确保现有功能不受影响
3. **数据保护**：迁移过程中的数据备份和回滚
4. **性能监控**：关键指标的监控和报警

## 总结

这个分类系统设计严格遵循 memos 项目的现有架构模式，确保代码一致性和可维护性。主要特点：

### 设计亮点
1. **架构一致性**：严格遵循四层架构和现有设计模式
2. **隐私保护**：分类作为私有元数据，确保用户隐私
3. **渐进集成**：最小侵入现有系统，支持逐步采用
4. **性能优先**：合理的缓存策略和查询优化
5. **扩展友好**：预留扩展空间，支持未来功能升级

### 技术决策
1. **路径冗余存储**：牺牲存储空间换取查询性能
2. **用户数据隔离**：通过 creator_id 实现严格的权限控制
3. **单一分类约束**：通过数据库设计强制业务规则
4. **标准字段组**：遵循项目既定的时间戳和状态管理模式

### 实施保障
1. **全面测试**：Store、API、前端三层测试覆盖
2. **迁移安全**：分步骤数据库迁移，支持回滚
3. **监控完善**：关键指标监控和性能跟踪
4. **文档齐全**：开发文档和用户文档同步更新

这个设计既满足了分类系统的功能需求，又保持了与现有系统的高度一致性，为项目的长期发展奠定了坚实的基础。