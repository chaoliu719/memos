# Memos åˆ†ç±»ç³»ç»Ÿå®Œæ•´è®¾è®¡æ–¹æ¡ˆ

## è®¾è®¡æ¦‚è¿°

### æ ¸å¿ƒè®¾è®¡åŸåˆ™

#### 1. éµå¾ªç°æœ‰æ¶æ„æ¨¡å¼
ä¸¥æ ¼æŒ‰ç…§ memos ç°æœ‰çš„æ¶æ„æ¨¡å¼å®ç°ï¼Œç¡®ä¿ä»£ç ä¸€è‡´æ€§å’Œå¯ç»´æŠ¤æ€§ï¼š
- ä½¿ç”¨ç°æœ‰çš„å››å±‚æ¶æ„ï¼šDatabase â†’ Store â†’ Service â†’ API
- éµå¾ªç°æœ‰çš„å‘½åè§„èŒƒã€é”™è¯¯å¤„ç†æ¨¡å¼ã€æ•°æ®æµè½¬æ–¹å¼
- å¤ç”¨ç°æœ‰çš„åŸºç¡€è®¾æ–½ï¼šç¼“å­˜ã€äº‹åŠ¡ç®¡ç†ã€æƒé™éªŒè¯

#### 2. åˆ†ç±»ä¸æ ‡ç­¾çš„æ˜ç¡®åŒºåˆ†
- **åˆ†ç±»(Category)**ï¼šå±‚çº§ç»„ç»‡ç»“æ„ï¼Œæ¯ä¸ª memo åªèƒ½å±äºä¸€ä¸ªåˆ†ç±»ï¼Œç§æœ‰å…ƒæ•°æ®
- **æ ‡ç­¾(Tags)**ï¼šæ‰å¹³ç‰¹å¾æ ‡è®°ï¼Œæ¯ä¸ª memo å¯ä»¥æœ‰å¤šä¸ªæ ‡ç­¾ï¼Œä»å†…å®¹æå–ï¼Œå…¬å¼€å¯è§

#### 3. éšç§ä¼˜å…ˆè®¾è®¡
åˆ†ç±»ä¿¡æ¯ä½œä¸ºç§æœ‰å…ƒæ•°æ®ï¼Œç±»ä¼¼äº `created_ts`ã€`updated_ts`ã€`visibility` ç­‰å­—æ®µï¼š
- åªæœ‰ memo åˆ›å»ºè€…å¯ä»¥çœ‹åˆ°åˆ†ç±»ä¿¡æ¯
- å…¬å¼€/ä¿æŠ¤çŠ¶æ€çš„ memo ä¸å¯¹å¤–æš´éœ²åˆ†ç±»ä¿¡æ¯
- API å“åº”ä¸­æ¡ä»¶æ€§è¿”å›åˆ†ç±»å­—æ®µ

#### 4. æ¸è¿›å¼é›†æˆ
- ç°æœ‰æ ‡ç­¾ç³»ç»Ÿå®Œå…¨ä¸å˜
- æ–°å¢åˆ†ç±»åŠŸèƒ½å®Œå…¨å¯é€‰
- ç°æœ‰ memo å¯ä¿æŒæœªåˆ†ç±»çŠ¶æ€
- æ”¯æŒç”¨æˆ·é€æ­¥é‡‡ç”¨åˆ†ç±»åŠŸèƒ½

## æ•°æ®åº“è®¾è®¡

### è®¾è®¡å†³ç­–

#### è¡¨è®¾è®¡éµå¾ªç°æœ‰æ¨¡å¼
ä¸¥æ ¼æŒ‰ç…§ memos ç°æœ‰çš„è¡¨è®¾è®¡æ¨¡å¼ï¼š
- ä½¿ç”¨æ ‡å‡†å­—æ®µç»„ï¼š`id`, `created_ts`, `updated_ts`, `row_status`
- å¤–é”®ä½¿ç”¨ `INTEGER` ç±»å‹ï¼Œä¸ `user.id` ä¿æŒä¸€è‡´
- è·¯å¾„å­—æ®µé™åˆ¶æœ€å¤§é•¿åº¦ **500 å­—ç¬¦**ï¼ˆåŸºäºç°æœ‰é¡¹ç›®çš„å­—ç¬¦ä¸²å­—æ®µé€šå¸¸é™åˆ¶ï¼‰
- é¢œè‰²å­—æ®µé™åˆ¶ **7 å­—ç¬¦**ï¼ˆæ”¯æŒ hex é¢œè‰²æ ¼å¼å¦‚ #FF0000ï¼‰
- å›¾æ ‡å­—æ®µé™åˆ¶ **20 å­—ç¬¦**ï¼ˆæ”¯æŒ emoji æˆ–ç®€çŸ­çš„å›¾æ ‡åç§°ï¼‰

#### ä¸ºä»€ä¹ˆè¦è·¯å¾„å†—ä½™å­˜å‚¨ï¼Ÿ
åŸºäº memos ç°æœ‰çš„æ€§èƒ½è€ƒè™‘æ¨¡å¼ï¼ˆå¦‚ memo çš„ payload å­—æ®µè®¾è®¡ï¼‰ï¼Œé€‰æ‹©è·¯å¾„å†—ä½™å­˜å‚¨ï¼š
- **æ€§èƒ½ä¼˜å…ˆ**ï¼šç•Œé¢æ˜¾ç¤ºæ—¶æ— éœ€é€’å½’æŸ¥è¯¢çˆ¶çº§è·¯å¾„ï¼Œç¬¦åˆé¡¹ç›®å¯¹æŸ¥è¯¢æ€§èƒ½çš„é‡è§†
- **æ’åºå‹å¥½**ï¼šç›´æ¥æŒ‰è·¯å¾„å­—ç¬¦ä¸²æ’åºå³å¯å¾—åˆ°å±‚çº§ç»“æ„ï¼Œç®€åŒ–å‰ç«¯é€»è¾‘
- **ç¼“å­˜å‹å¥½**ï¼šè·¯å¾„ä¿¡æ¯è‡ªåŒ…å«ï¼Œå‡å°‘ JOIN æŸ¥è¯¢ï¼Œç¬¦åˆé¡¹ç›®çš„ç¼“å­˜è®¾è®¡æ¨¡å¼

### æ•°æ®åº“ç»“æ„

#### æ–°å»º category è¡¨
```sql
-- åˆ†ç±»è¡¨è®¾è®¡ï¼Œä¸¥æ ¼éµå¾ª memos è¡¨è®¾è®¡è§„èŒƒ
CREATE TABLE category (
  -- æ ‡å‡†ä¸»é”®ï¼Œä¸å…¶ä»–è¡¨ä¿æŒä¸€è‡´
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  
  -- åˆ†ç±»åç§°ï¼Œé™åˆ¶é•¿åº¦é˜²æ­¢è¶…é•¿è¾“å…¥
  name TEXT NOT NULL CHECK (length(name) <= 100 AND length(name) > 0),
  
  -- å®Œæ•´è·¯å¾„ï¼Œå†—ä½™å­˜å‚¨æå‡æŸ¥è¯¢æ€§èƒ½
  path TEXT NOT NULL CHECK (length(path) <= 500 AND length(path) > 0),
  
  -- çˆ¶åˆ†ç±»å¼•ç”¨ï¼ŒNULL è¡¨ç¤ºæ ¹åˆ†ç±»
  parent_id INTEGER REFERENCES category(id) ON DELETE CASCADE,
  
  -- åˆ›å»ºè€…ï¼Œä¸¥æ ¼æƒé™éš”ç¦»
  creator_id INTEGER NOT NULL REFERENCES user(id) ON DELETE CASCADE,
  
  -- UI å±•ç¤ºå±æ€§
  color TEXT NOT NULL DEFAULT '#6366f1' CHECK (color REGEXP '^#[0-9A-Fa-f]{6}$'),
  icon TEXT NOT NULL DEFAULT 'ğŸ“' CHECK (length(icon) <= 20),
  
  -- æ ‡å‡†æ—¶é—´æˆ³å­—æ®µï¼Œä¸å…¶ä»–è¡¨ä¿æŒä¸€è‡´
  created_ts BIGINT NOT NULL DEFAULT (strftime('%s', 'now')),
  updated_ts BIGINT NOT NULL DEFAULT (strftime('%s', 'now')),
  
  -- æ ‡å‡†çŠ¶æ€å­—æ®µï¼Œæ”¯æŒè½¯åˆ é™¤
  row_status TEXT NOT NULL DEFAULT 'NORMAL' CHECK (row_status IN ('NORMAL', 'ARCHIVED'))
);

-- æ€§èƒ½ä¼˜åŒ–ç´¢å¼•ï¼ŒåŸºäºé¢„æœŸæŸ¥è¯¢æ¨¡å¼
CREATE INDEX idx_category_creator_id ON category(creator_id) WHERE row_status = 'NORMAL';
CREATE INDEX idx_category_parent_id ON category(parent_id) WHERE row_status = 'NORMAL';

-- ä¸šåŠ¡çº¦æŸç´¢å¼•ï¼Œé˜²æ­¢åŒä¸€ç”¨æˆ·åˆ›å»ºé‡å¤è·¯å¾„
CREATE UNIQUE INDEX idx_category_path_creator ON category(path, creator_id) WHERE row_status = 'NORMAL';

-- é˜²æ­¢å±‚çº§è¿‡æ·±çš„çº¦æŸæ£€æŸ¥ï¼ˆæœ€å¤§ 10 çº§ï¼‰
-- é€šè¿‡è·¯å¾„ä¸­çš„ '/' æ•°é‡æ§åˆ¶ï¼špath REGEXP '^([^/]+/){0,9}[^/]+$'
```

#### æ‰©å±• memo è¡¨
```sql
-- ä¸ºç°æœ‰ memo è¡¨æ·»åŠ åˆ†ç±»å¼•ç”¨
-- ä½¿ç”¨å¯ç©ºå¤–é”®ï¼Œä¿æŒå‘åå…¼å®¹æ€§
ALTER TABLE memo ADD COLUMN category_id INTEGER REFERENCES category(id) ON DELETE SET NULL;

-- æ·»åŠ ç´¢å¼•æ”¯æŒæŒ‰åˆ†ç±»æŸ¥è¯¢ï¼Œè¿™æ˜¯æ ¸å¿ƒä½¿ç”¨åœºæ™¯
CREATE INDEX idx_memo_category_id ON memo(category_id) WHERE row_status = 'NORMAL';
```

### ä¸ºä»€ä¹ˆè¿™æ ·è®¾è®¡ï¼Ÿ

#### 1. çº§è”åˆ é™¤ç­–ç•¥
- **`category.creator_id â†’ user.id`**: ç”¨æˆ·åˆ é™¤æ—¶çº§è”åˆ é™¤æ‰€æœ‰åˆ†ç±»ï¼ˆä¸šåŠ¡åˆç†æ€§ï¼‰
- **`category.parent_id â†’ category.id`**: çˆ¶åˆ†ç±»åˆ é™¤æ—¶çº§è”åˆ é™¤å­åˆ†ç±»ï¼ˆæ•°æ®ä¸€è‡´æ€§ï¼‰
- **`memo.category_id â†’ category.id`**: åˆ†ç±»åˆ é™¤æ—¶å°† memo è®¾ä¸ºæœªåˆ†ç±»ï¼ˆæ•°æ®ä¿æŠ¤ï¼‰

#### 2. çº¦æŸè®¾è®¡ç†ç”±
- **é•¿åº¦çº¦æŸ**ï¼šåŸºäºå®é™…ä½¿ç”¨åœºæ™¯ï¼Œé˜²æ­¢æ¶æ„è¾“å…¥æˆ–è¯¯æ“ä½œ
- **é¢œè‰²æ ¼å¼çº¦æŸ**ï¼šç¡®ä¿å‰ç«¯å¯æ­£ç¡®è§£æå’Œæ˜¾ç¤º
- **è·¯å¾„å”¯ä¸€æ€§**ï¼šé˜²æ­¢åŒä¸€ç”¨æˆ·åˆ›å»ºå†²çªçš„åˆ†ç±»ç»“æ„

#### 3. ç´¢å¼•ç­–ç•¥
éµå¾ª memos ç°æœ‰çš„ç´¢å¼•è®¾è®¡æ¨¡å¼ï¼š
- **å•åˆ—ç´¢å¼•**ï¼šæ”¯æŒåŸºç¡€æŸ¥è¯¢ï¼Œå¦‚æŒ‰åˆ›å»ºè€…åˆ—å‡ºåˆ†ç±»
- **å¤åˆç´¢å¼•**ï¼šæ”¯æŒå¤æ‚æŸ¥è¯¢ï¼Œå¦‚ç”¨æˆ· + è·¯å¾„å”¯ä¸€æ€§
- **æ¡ä»¶ç´¢å¼•**ï¼šåªå¯¹æœ‰æ•ˆæ•°æ®å»ºç´¢å¼•ï¼Œæå‡æ€§èƒ½

## Store å±‚è®¾è®¡

### éµå¾ªç°æœ‰æ¨¡å¼çš„æ•°æ®æ¨¡å‹

#### Category å®ä½“è®¾è®¡
ä¸¥æ ¼æŒ‰ç…§ memos ç°æœ‰å®ä½“è®¾è®¡æ¨¡å¼ï¼š
```go
// store/category.go - éµå¾ªç°æœ‰å‘½åå’Œå­—æ®µç»„ç»‡æ–¹å¼
type Category struct {
    // ç³»ç»Ÿæ ‡è¯†ç¬¦ - ä¸å…¶ä»–å®ä½“ä¿æŒä¸€è‡´
    ID int32

    // æ ‡å‡†å­—æ®µç»„ - ä¸ memoã€user ç­‰å®ä½“ä¿æŒä¸€è‡´
    RowStatus RowStatus
    CreatorID int32
    CreatedTs int64
    UpdatedTs int64

    // é¢†åŸŸç‰¹å®šå­—æ®µ - æŒ‰åŠŸèƒ½åˆ†ç»„
    Name     string
    Path     string
    ParentID *int32  // ä½¿ç”¨æŒ‡é’ˆç±»å‹è¡¨ç¤ºå¯ç©ºï¼Œä¸ç°æœ‰æ¨¡å¼ä¸€è‡´

    // UI å±æ€§å­—æ®µ
    Color string
    Icon  string
}
```

#### ä¸ºä»€ä¹ˆä¸ä½¿ç”¨ UID å­—æ®µï¼Ÿ
åŸºäºè°ƒç ”ï¼Œmemo ä½¿ç”¨ UID æ˜¯å› ä¸ºéœ€è¦æ”¯æŒç”¨æˆ·è‡ªå®šä¹‰æ ‡è¯†ç¬¦ã€‚åˆ†ç±»ç³»ç»Ÿä¸éœ€è¦è¿™ä¸ªç‰¹æ€§ï¼Œæ‰€ä»¥éµå¾ªæ›´ç®€å•çš„è®¾è®¡ï¼Œåªä½¿ç”¨ç³»ç»Ÿç”Ÿæˆçš„ IDã€‚

#### FindCategory æŸ¥è¯¢æ¨¡å‹
éµå¾ªç°æœ‰çš„ FindXXX è®¾è®¡æ¨¡å¼ï¼š
```go
type FindCategory struct {
    // ç²¾ç¡®åŒ¹é…æ¡ä»¶ - æŒ‡é’ˆç±»å‹è¡¨ç¤ºå¯é€‰
    ID         *int32
    CreatorID  *int32
    ParentID   *int32    // ç‰¹æ®Šï¼šnil è¡¨ç¤ºæŸ¥è¯¢æ ¹åˆ†ç±»
    RowStatus  *RowStatus

    // åˆ†ç±»ç‰¹æœ‰æŸ¥è¯¢æ¡ä»¶
    PathPrefix *string   // æ”¯æŒæŸ¥è¯¢å­åˆ†ç±»æ ‘
    MaxDepth   *int      // é™åˆ¶æŸ¥è¯¢æ·±åº¦ï¼Œé»˜è®¤æ— é™åˆ¶

    // æ ‡å‡†åˆ†é¡µå‚æ•° - ä¸å…¶ä»– Find ç»“æ„ä¿æŒä¸€è‡´
    Limit  *int
    Offset *int
}
```

#### ä¸ºä»€ä¹ˆå¢åŠ  MaxDepth å‚æ•°ï¼Ÿ
åŸºäºæ€§èƒ½è€ƒè™‘ï¼Œæä¾›æ·±åº¦é™åˆ¶é¿å…æ¶æ„æ·±å±‚åµŒå¥—å¯¼è‡´çš„æ€§èƒ½é—®é¢˜ã€‚è¿™æ˜¯å¯¹ç°æœ‰è®¾è®¡çš„åˆç†æ‰©å±•ã€‚

#### UpdateCategory æ›´æ–°æ¨¡å‹
```go
type UpdateCategory struct {
    ID int32  // å¿…éœ€å­—æ®µï¼Œç”¨äºå®šä½è®°å½•

    // å¯é€‰æ›´æ–°å­—æ®µ - æŒ‡é’ˆç±»å‹ï¼Œnil è¡¨ç¤ºä¸æ›´æ–°
    Name      *string
    ParentID  *int32   // æ”¯æŒç§»åŠ¨åˆ†ç±»
    Color     *string
    Icon      *string
    RowStatus *RowStatus
    UpdatedTs *int64   // æ‰‹åŠ¨æ§åˆ¶æ›´æ–°æ—¶é—´
}
```

### Store æ¥å£æ‰©å±•

#### éµå¾ªç°æœ‰æ¥å£è®¾è®¡æ¨¡å¼
```go
// store/store.go - åœ¨ç°æœ‰ Store æ¥å£ä¸­æ·»åŠ 
type Store interface {
    // ... ç°æœ‰æ–¹æ³•

    // åŸºç¡€ CRUD æ“ä½œ - éµå¾ªç°æœ‰å‘½åæ¨¡å¼
    CreateCategory(ctx context.Context, create *Category) (*Category, error)
    ListCategories(ctx context.Context, find *FindCategory) ([]*Category, error)
    GetCategory(ctx context.Context, find *FindCategory) (*Category, error)
    UpdateCategory(ctx context.Context, update *UpdateCategory) (*Category, error)
    DeleteCategory(ctx context.Context, id int32) error

    // åˆ†ç±»ç‰¹æœ‰çš„å¤æ‚æ“ä½œ
    GetCategoryTree(ctx context.Context, creatorID int32, rootID *int32) ([]*Category, error)
    MoveCategoryTree(ctx context.Context, categoryID int32, newParentID *int32) error
    CountMemosByCategory(ctx context.Context, categoryID int32) (int32, error)
    UncategorizeMemosByCategory(ctx context.Context, categoryID int32) error
}
```

#### ä¸ºä»€ä¹ˆéœ€è¦è¿™äº›ç‰¹æ®Šæ–¹æ³•ï¼Ÿ
- **GetCategoryTree**: ä¸€æ¬¡æ€§è·å–åˆ†ç±»æ ‘ï¼Œå‡å°‘ N+1 æŸ¥è¯¢é—®é¢˜
- **MoveCategoryTree**: åŸå­æ€§ç§»åŠ¨åˆ†ç±»åŠå…¶å­åˆ†ç±»ï¼Œä¿è¯æ•°æ®ä¸€è‡´æ€§
- **CountMemosByCategory**: åˆ é™¤å‰æ£€æŸ¥ä¾èµ–ï¼Œéµå¾ªè°¨æ…åˆ é™¤åŸåˆ™
- **UncategorizeMemosByCategory**: å¼ºåˆ¶åˆ é™¤æ—¶çš„æ¸…ç†æ“ä½œ

### æ•°æ®åº“å±‚å®ç°è¦ç‚¹

#### éµå¾ªç°æœ‰çš„é”™è¯¯å¤„ç†æ¨¡å¼
```go
// store/db/sqlite/category.go - éµå¾ªç°æœ‰æ•°æ®åº“å±‚è®¾è®¡
func (d *DB) CreateCategory(ctx context.Context, create *Category) (*Category, error) {
    // 1. ä¸šåŠ¡éªŒè¯ - åœ¨æ•°æ®åº“å±‚è¿›è¡ŒåŸºç¡€éªŒè¯
    if create.ParentID != nil {
        if err := d.validateParentCategory(ctx, *create.ParentID, create.CreatorID); err != nil {
            return nil, err  // ç›´æ¥è¿”å›é”™è¯¯ï¼Œä¸åŒ…è£…
        }
    }

    // 2. è·¯å¾„ç”Ÿæˆ - ç¡®ä¿è·¯å¾„çš„æ­£ç¡®æ€§
    path, err := d.generateCategoryPath(ctx, create.Name, create.ParentID, create.CreatorID)
    if err != nil {
        return nil, err
    }
    create.Path = path

    // 3. æ•°æ®åº“æ’å…¥ - ä½¿ç”¨ç°æœ‰çš„æŸ¥è¯¢æ¨¡å¼
    query := `
        INSERT INTO category (name, path, parent_id, creator_id, color, icon, created_ts, updated_ts, row_status)
        VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
    `
    
    result, err := d.db.ExecContext(ctx, query,
        create.Name, create.Path, create.ParentID, create.CreatorID,
        create.Color, create.Icon, create.CreatedTs, create.UpdatedTs, create.RowStatus,
    )
    if err != nil {
        return nil, err
    }

    // 4. è·å–ç”Ÿæˆçš„ ID - éµå¾ªç°æœ‰æ¨¡å¼
    id, err := result.LastInsertId()
    if err != nil {
        return nil, err
    }
    create.ID = int32(id)

    return create, nil
}
```

#### ä¸ºä»€ä¹ˆåœ¨è¿™é‡Œè¿›è¡ŒéªŒè¯ï¼Ÿ
éµå¾ªç°æœ‰é¡¹ç›®çš„éªŒè¯ç­–ç•¥ï¼š
- **æ•°æ®åº“çº¦æŸ**ï¼šç¡®ä¿æ•°æ®å®Œæ•´æ€§ï¼ˆå¤–é”®ã€å”¯ä¸€æ€§ç­‰ï¼‰
- **Store å±‚éªŒè¯**ï¼šä¸šåŠ¡è§„åˆ™éªŒè¯ï¼ˆçˆ¶åˆ†ç±»å­˜åœ¨æ€§ã€æƒé™ç­‰ï¼‰
- **Service å±‚éªŒè¯**ï¼šå¤æ‚ä¸šåŠ¡é€»è¾‘éªŒè¯

#### è·¯å¾„ç”Ÿæˆå®ç°
```go
func (d *DB) generateCategoryPath(ctx context.Context, name string, parentID *int32, creatorID int32) (string, error) {
    // æ ¹åˆ†ç±»ç›´æ¥è¿”å›åç§°
    if parentID == nil {
        return name, nil
    }

    // è·å–çˆ¶åˆ†ç±»è·¯å¾„
    parent, err := d.GetCategory(ctx, &FindCategory{
        ID:        parentID,
        CreatorID: &creatorID,  // ç¡®ä¿æƒé™æ£€æŸ¥
        RowStatus: &Normal,
    })
    if err != nil {
        return "", fmt.Errorf("parent category not found: %w", err)
    }

    // æ£€æŸ¥è·¯å¾„æ·±åº¦é™åˆ¶ï¼ˆæœ€å¤§ 10 çº§ï¼‰
    depth := strings.Count(parent.Path, "/") + 1
    if depth >= 10 {
        return "", errors.New("category depth limit exceeded (max 10 levels)")
    }

    return parent.Path + "/" + name, nil
}
```

#### ä¸ºä»€ä¹ˆé™åˆ¶ 10 çº§æ·±åº¦ï¼Ÿ
åŸºäºå®é™…ä½¿ç”¨åœºæ™¯å’Œæ€§èƒ½è€ƒè™‘ï¼š
- **å®ç”¨æ€§**ï¼š10 çº§æ·±åº¦è¶³å¤Ÿç»å¤§å¤šæ•°ä½¿ç”¨åœºæ™¯
- **æ€§èƒ½**ï¼šé¿å…è¿‡æ·±å±‚çº§å¯¼è‡´çš„æŸ¥è¯¢æ€§èƒ½é—®é¢˜
- **ç”¨æˆ·ä½“éªŒ**ï¼šè¿‡æ·±çš„å±‚çº§ç»“æ„å¯¹ç”¨æˆ·ä¸å‹å¥½

### Memo æ¨¡å‹æ‰©å±•

#### æœ€å°åŒ–ä¿®æ”¹ç°æœ‰ Memo ç»“æ„
```go
// store/memo.go - åœ¨ç°æœ‰ Memo ç»“æ„ä¸­æ·»åŠ 
type Memo struct {
    // ... ç°æœ‰æ‰€æœ‰å­—æ®µä¿æŒä¸å˜

    // æ–°å¢åˆ†ç±»å¼•ç”¨ - å¯ç©ºå­—æ®µï¼Œä¿æŒå‘åå…¼å®¹
    CategoryID *int32
}

// æ‰©å±•ç°æœ‰ FindMemo æŸ¥è¯¢æ¡ä»¶
type FindMemo struct {
    // ... ç°æœ‰æ‰€æœ‰å­—æ®µä¿æŒä¸å˜

    // æ–°å¢åˆ†ç±»æŸ¥è¯¢æ¡ä»¶
    CategoryID           *int32    // ç²¾ç¡®åˆ†ç±»åŒ¹é…
    CategoryIDs          []int32   // å¤šåˆ†ç±»åŒ¹é…ï¼ˆIN æŸ¥è¯¢ï¼‰
    IncludeSubcategories bool      // æ˜¯å¦åŒ…å«å­åˆ†ç±»
    ExcludeCategorized   bool      // æ˜¯å¦æ’é™¤å·²åˆ†ç±»çš„ memo
}

// æ‰©å±•ç°æœ‰ UpdateMemo ç»“æ„
type UpdateMemo struct {
    // ... ç°æœ‰æ‰€æœ‰å­—æ®µä¿æŒä¸å˜

    // æ–°å¢åˆ†ç±»æ›´æ–°å­—æ®µ
    CategoryID *int32  // nil è¡¨ç¤ºå–æ¶ˆåˆ†ç±»
}
```

#### ä¸ºä»€ä¹ˆè¿™æ ·æ‰©å±•ï¼Ÿ
- **æœ€å°ä¾µå…¥**ï¼šåªæ·»åŠ å¿…è¦å­—æ®µï¼Œä¸ä¿®æ”¹ç°æœ‰é€»è¾‘
- **å‘åå…¼å®¹**ï¼šç°æœ‰ä»£ç æ— éœ€ä¿®æ”¹å³å¯æ­£å¸¸è¿è¡Œ
- **åŠŸèƒ½å®Œæ•´**ï¼šæ”¯æŒæ‰€æœ‰å¿…è¦çš„åˆ†ç±»æŸ¥è¯¢åœºæ™¯

## Protocol Buffer è®¾è®¡

### éµå¾ªç°æœ‰ Proto è®¾è®¡è§„èŒƒ

#### Store Proto å®šä¹‰
```protobuf
// proto/store/category.proto - éµå¾ªç°æœ‰ store proto æ¨¡å¼
syntax = "proto3";

package memos.store;

option go_package = "gen/store";

message Category {
  int32 id = 1;
  string name = 2;
  string path = 3;
  int32 parent_id = 4;           // 0 è¡¨ç¤ºæ ¹åˆ†ç±»ï¼Œä¸ç°æœ‰ proto çš„ int32 ä¹ æƒ¯ä¸€è‡´
  int32 creator_id = 5;
  string color = 6;
  string icon = 7;
  int64 created_ts = 8;
  int64 updated_ts = 9;
  string row_status = 10;        // æšä¸¾å­—ç¬¦ä¸²ï¼Œä¸ç°æœ‰æ¨¡å¼ä¸€è‡´
}
```

#### API Proto å®šä¹‰
```protobuf
// proto/api/v1/category_service.proto - éµå¾ªç°æœ‰ API proto æ¨¡å¼
syntax = "proto3";

package memos.api.v1;

import "google/api/annotations.proto";
import "google/api/field_behavior.proto";
import "google/api/resource.proto";
import "google/protobuf/empty.proto";
import "google/protobuf/field_mask.proto";
import "google/protobuf/timestamp.proto";

// åˆ†ç±»æœåŠ¡å®šä¹‰ - éµå¾ªç°æœ‰æœåŠ¡å‘½åå’Œæ“ä½œæ¨¡å¼
service CategoryService {
  // åˆ›å»ºåˆ†ç±» - POST /api/v1/categories
  rpc CreateCategory(CreateCategoryRequest) returns (Category) {
    option (google.api.http) = {
      post: "/api/v1/categories"
      body: "category"
    };
    option (google.api.method_signature) = "category";
  }

  // åˆ—å‡ºåˆ†ç±» - GET /api/v1/categories
  rpc ListCategories(ListCategoriesRequest) returns (ListCategoriesResponse) {
    option (google.api.http) = {get: "/api/v1/categories"};
    option (google.api.method_signature) = "";
  }

  // è·å–åˆ†ç±» - GET /api/v1/{name=categories/*}
  rpc GetCategory(GetCategoryRequest) returns (Category) {
    option (google.api.http) = {get: "/api/v1/{name=categories/*}"};
    option (google.api.method_signature) = "name";
  }

  // æ›´æ–°åˆ†ç±» - PATCH /api/v1/{category.name=categories/*}
  rpc UpdateCategory(UpdateCategoryRequest) returns (Category) {
    option (google.api.http) = {
      patch: "/api/v1/{category.name=categories/*}"
      body: "category"
    };
    option (google.api.method_signature) = "category,update_mask";
  }

  // åˆ é™¤åˆ†ç±» - DELETE /api/v1/{name=categories/*}
  rpc DeleteCategory(DeleteCategoryRequest) returns (google.protobuf.Empty) {
    option (google.api.http) = {delete: "/api/v1/{name=categories/*}"};
    option (google.api.method_signature) = "name";
  }

  // ç§»åŠ¨åˆ†ç±» - POST /api/v1/{name=categories/*}:move
  rpc MoveCategory(MoveCategoryRequest) returns (Category) {
    option (google.api.http) = {
      post: "/api/v1/{name=categories/*}:move"
      body: "*"
    };
    option (google.api.method_signature) = "name,parent";
  }
}

// åˆ†ç±»èµ„æºå®šä¹‰ - éµå¾ª Google API èµ„æºå‘½åè§„èŒƒ
message Category {
  option (google.api.resource) = {
    type: "memos.api.v1/Category"
    pattern: "categories/{category}"
    name_field: "name"
    singular: "category"
    plural: "categories"
  };

  // èµ„æºåç§° - categories/{category_id}ï¼Œä¸ç°æœ‰èµ„æºå‘½åä¿æŒä¸€è‡´
  string name = 1 [(google.api.field_behavior) = IDENTIFIER];

  // æ˜¾ç¤ºåç§° - ç”¨æˆ·è¾“å…¥çš„åˆ†ç±»åç§°
  string display_name = 2 [(google.api.field_behavior) = REQUIRED];

  // å®Œæ•´è·¯å¾„ - åªè¯»å­—æ®µï¼ŒæœåŠ¡ç«¯ç”Ÿæˆ
  string path = 3 [(google.api.field_behavior) = OUTPUT_ONLY];

  // çˆ¶åˆ†ç±»å¼•ç”¨ - categories/{parent_id}ï¼Œå¯é€‰
  optional string parent = 4 [
    (google.api.field_behavior) = OPTIONAL,
    (google.api.resource_reference) = {type: "memos.api.v1/Category"}
  ];

  // UI å±æ€§
  string color = 5 [(google.api.field_behavior) = OPTIONAL];
  string icon = 6 [(google.api.field_behavior) = OPTIONAL];

  // æ ‡å‡†æ—¶é—´æˆ³ - ä¸å…¶ä»–èµ„æºä¿æŒä¸€è‡´
  google.protobuf.Timestamp create_time = 7 [(google.api.field_behavior) = OUTPUT_ONLY];
  google.protobuf.Timestamp update_time = 8 [(google.api.field_behavior) = OUTPUT_ONLY];
}
```

#### ä¸ºä»€ä¹ˆè¿™æ ·è®¾è®¡ Protoï¼Ÿ
1. **èµ„æºå‘½åä¸€è‡´æ€§**ï¼š`categories/{category_id}` ä¸ `memos/{memo_id}` ä¿æŒä¸€è‡´
2. **å­—æ®µè¡Œä¸ºæ ‡æ³¨**ï¼šæ˜ç¡®æŒ‡ç¤ºå­—æ®µçš„è¾“å…¥/è¾“å‡ºå±æ€§ï¼Œä¾¿äºå®¢æˆ·ç«¯å¼€å‘
3. **HTTP æ˜ å°„å®Œæ•´**ï¼šæ¯ä¸ª RPC éƒ½æœ‰å¯¹åº”çš„ RESTful API è·¯å¾„
4. **æ–¹æ³•ç­¾åå£°æ˜**ï¼šä¾¿äº gRPC å®¢æˆ·ç«¯ç”Ÿæˆä»£ç 

### æ‰©å±• Memo Proto

#### åœ¨ç°æœ‰ Memo æ¶ˆæ¯ä¸­æ·»åŠ åˆ†ç±»å­—æ®µ
```protobuf
// proto/api/v1/memo_service.proto - åœ¨ç°æœ‰ Memo æ¶ˆæ¯ä¸­æ·»åŠ 
message Memo {
  // ... ç°æœ‰æ‰€æœ‰å­—æ®µä¿æŒä¸å˜

  // åˆ†ç±»ä¿¡æ¯ - åªæœ‰åˆ›å»ºè€…å¯è§ï¼ŒOUTPUT_ONLY è¡¨ç¤ºåªè¯»
  optional Category category = 25 [(google.api.field_behavior) = OUTPUT_ONLY];
}

// åœ¨ç°æœ‰ ListMemosRequest ä¸­æ·»åŠ åˆ†ç±»è¿‡æ»¤
message ListMemosRequest {
  // ... ç°æœ‰æ‰€æœ‰å­—æ®µä¿æŒä¸å˜

  // åˆ†ç±»è¿‡æ»¤æ¡ä»¶
  optional string category = 11 [
    (google.api.field_behavior) = OPTIONAL,
    (google.api.resource_reference) = {type: "memos.api.v1/Category"}
  ];
  
  repeated string categories = 12 [
    (google.api.field_behavior) = OPTIONAL,
    (google.api.resource_reference) = {type: "memos.api.v1/Category"}
  ];
  
  bool include_subcategories = 13 [(google.api.field_behavior) = OPTIONAL];
}

// æ–°å¢è®¾ç½® memo åˆ†ç±»çš„æ“ä½œ
message SetMemoCategoryRequest {
  // memo èµ„æºåç§°
  string name = 1 [
    (google.api.field_behavior) = REQUIRED,
    (google.api.resource_reference) = {type: "memos.api.v1/Memo"}
  ];

  // åˆ†ç±»èµ„æºåç§°ï¼Œç©ºè¡¨ç¤ºå–æ¶ˆåˆ†ç±»
  optional string category = 2 [
    (google.api.field_behavior) = OPTIONAL,
    (google.api.resource_reference) = {type: "memos.api.v1/Category"}
  ];
}

// åœ¨ MemoService ä¸­æ·»åŠ è®¾ç½®åˆ†ç±»çš„ RPC
service MemoService {
  // ... ç°æœ‰æ‰€æœ‰ RPC ä¿æŒä¸å˜

  // è®¾ç½® memo åˆ†ç±» - PATCH /api/v1/{name=memos/*}:setCategory
  rpc SetMemoCategory(SetMemoCategoryRequest) returns (google.protobuf.Empty) {
    option (google.api.http) = {
      patch: "/api/v1/{name=memos/*}:setCategory"
      body: "*"
    };
    option (google.api.method_signature) = "name,category";
  }
}
```

#### ä¸ºä»€ä¹ˆåœ¨ MemoService ä¸­æ·»åŠ  SetMemoCategoryï¼Ÿ
- **èŒè´£æ¸…æ™°**ï¼šåˆ†ç±»åˆ†é…æ˜¯å¯¹ memo çš„æ“ä½œï¼Œåº”è¯¥åœ¨ MemoService ä¸­
- **æƒé™ä¸€è‡´**ï¼šå¤ç”¨ç°æœ‰çš„ memo æƒé™éªŒè¯é€»è¾‘
- **äº‹åŠ¡è¾¹ç•Œ**ï¼šmemo æ›´æ–°æ“ä½œçš„äº‹åŠ¡è¾¹ç•Œæ¸…æ™°

## API Service å±‚è®¾è®¡

### CategoryService å®ç°ç­–ç•¥

#### éµå¾ªç°æœ‰æœåŠ¡å®ç°æ¨¡å¼
```go
// server/router/api/v1/category_service.go
type CategoryService struct {
    apiv1pb.UnimplementedCategoryServiceServer
    Store  *store.Store
    Secret string  // éµå¾ªç°æœ‰çš„è®¤è¯è®¾è®¡
}

func NewCategoryService(store *store.Store, secret string) *CategoryService {
    return &CategoryService{
        Store:  store,
        Secret: secret,
    }
}

// éµå¾ªç°æœ‰çš„ç”¨æˆ·è®¤è¯æ¨¡å¼
func (s *CategoryService) getCurrentUser(ctx context.Context) (*store.User, error) {
    return getCurrentUser(ctx, s.Store, s.Secret)
}
```

#### CreateCategory å®ç°è¦ç‚¹
```go
func (s *CategoryService) CreateCategory(ctx context.Context, req *apiv1pb.CreateCategoryRequest) (*apiv1pb.Category, error) {
    // 1. ç”¨æˆ·è®¤è¯ - éµå¾ªç°æœ‰è®¤è¯æ¨¡å¼
    user, err := s.getCurrentUser(ctx)
    if err != nil {
        return nil, status.Errorf(codes.Unauthenticated, "failed to get current user")
    }

    // 2. è¾“å…¥éªŒè¯ - éµå¾ªç°æœ‰éªŒè¯æ¨¡å¼
    if req.Category == nil {
        return nil, status.Errorf(codes.InvalidArgument, "category is required")
    }
    if req.Category.DisplayName == "" {
        return nil, status.Errorf(codes.InvalidArgument, "display_name is required")
    }

    // 3. æ„å»º Store æ¨¡å‹ - éµå¾ªç°æœ‰è½¬æ¢æ¨¡å¼
    storeCategory := &store.Category{
        Name:      req.Category.DisplayName,
        CreatorID: user.ID,
        Color:     req.Category.Color,
        Icon:      req.Category.Icon,
        CreatedTs: time.Now().Unix(),
        UpdatedTs: time.Now().Unix(),
        RowStatus: store.Normal,
    }

    // 4. å¤„ç†çˆ¶åˆ†ç±»å¼•ç”¨
    if req.Category.Parent != "" {
        parentID, err := extractCategoryID(req.Category.Parent)
        if err != nil {
            return nil, status.Errorf(codes.InvalidArgument, "invalid parent category: %v", err)
        }
        
        // éªŒè¯çˆ¶åˆ†ç±»æƒé™
        _, err = s.Store.GetCategory(ctx, &store.FindCategory{
            ID:        &parentID,
            CreatorID: &user.ID,
            RowStatus: &store.Normal,
        })
        if err != nil {
            return nil, status.Errorf(codes.NotFound, "parent category not found")
        }
        
        storeCategory.ParentID = &parentID
    }

    // 5. åˆ›å»ºåˆ†ç±» - Store å±‚å¤„ç†å¤æ‚é€»è¾‘
    created, err := s.Store.CreateCategory(ctx, storeCategory)
    if err != nil {
        // æ ¹æ®é”™è¯¯ç±»å‹è¿”å›é€‚å½“çš„ gRPC é”™è¯¯ç 
        if strings.Contains(err.Error(), "UNIQUE constraint failed") {
            return nil, status.Errorf(codes.AlreadyExists, "category path already exists")
        }
        if strings.Contains(err.Error(), "depth limit exceeded") {
            return nil, status.Errorf(codes.InvalidArgument, err.Error())
        }
        return nil, status.Errorf(codes.Internal, "failed to create category")
    }

    // 6. è½¬æ¢ä¸º API æ¨¡å‹å¹¶è¿”å›
    return convertCategoryFromStore(created), nil
}
```

#### ä¸ºä»€ä¹ˆè¿™æ ·å¤„ç†é”™è¯¯ï¼Ÿ
éµå¾ªç°æœ‰é¡¹ç›®çš„é”™è¯¯å¤„ç†æ¨¡å¼ï¼š
- **Store å±‚**ï¼šè¿”å›åŸå§‹é”™è¯¯ï¼Œä¸åŒ…è£…
- **Service å±‚**ï¼šå°†æ•°æ®åº“é”™è¯¯è½¬æ¢ä¸ºä¸šåŠ¡é”™è¯¯
- **gRPC å±‚**ï¼šå°†ä¸šåŠ¡é”™è¯¯è½¬æ¢ä¸ºæ ‡å‡† gRPC çŠ¶æ€ç 

#### ListCategories å®ç° - æ”¯æŒæ ‘å½¢ç»“æ„
```go
func (s *CategoryService) ListCategories(ctx context.Context, req *apiv1pb.ListCategoriesRequest) (*apiv1pb.ListCategoriesResponse, error) {
    user, err := s.getCurrentUser(ctx)
    if err != nil {
        return nil, status.Errorf(codes.Unauthenticated, "failed to get current user")
    }

    // æ„å»ºæŸ¥è¯¢æ¡ä»¶
    find := &store.FindCategory{
        CreatorID: &user.ID,
        RowStatus: &store.Normal,
    }

    // å¤„ç†åˆ†é¡µå‚æ•° - éµå¾ªç°æœ‰åˆ†é¡µæ¨¡å¼
    if req.PageSize > 0 {
        limit := min(int(req.PageSize), 1000)  // é™åˆ¶æœ€å¤§é¡µé¢å¤§å°
        find.Limit = &limit
    }
    
    if req.PageToken != "" {
        offset, err := parsePageToken(req.PageToken)
        if err != nil {
            return nil, status.Errorf(codes.InvalidArgument, "invalid page token")
        }
        find.Offset = &offset
    }

    // æŸ¥è¯¢åˆ†ç±»
    categories, err := s.Store.ListCategories(ctx, find)
    if err != nil {
        return nil, status.Errorf(codes.Internal, "failed to list categories")
    }

    // è½¬æ¢å¹¶æ„å»ºå“åº”
    apiCategories := make([]*apiv1pb.Category, len(categories))
    for i, category := range categories {
        apiCategories[i] = convertCategoryFromStore(category)
    }

    response := &apiv1pb.ListCategoriesResponse{
        Categories: apiCategories,
        TotalSize:  int32(len(apiCategories)), // ç®€åŒ–å®ç°ï¼Œå®é™…å¯èƒ½éœ€è¦å•ç‹¬æŸ¥è¯¢æ€»æ•°
    }

    // ç”Ÿæˆä¸‹ä¸€é¡µ token
    if find.Limit != nil && len(categories) >= *find.Limit {
        nextOffset := 0
        if find.Offset != nil {
            nextOffset = *find.Offset
        }
        nextOffset += len(categories)
        response.NextPageToken = generatePageToken(nextOffset)
    }

    return response, nil
}
```

### MemoService æ‰©å±•å®ç°

#### æ‰©å±•ç°æœ‰ GetMemo æ–¹æ³•
```go
// server/router/api/v1/memo_service.go - åœ¨ç°æœ‰ GetMemo æ–¹æ³•ä¸­æ·»åŠ åˆ†ç±»ä¿¡æ¯
func (s *MemoService) GetMemo(ctx context.Context, req *apiv1pb.GetMemoRequest) (*apiv1pb.Memo, error) {
    // ... ç°æœ‰çš„ memo è·å–é€»è¾‘ä¿æŒä¸å˜

    // è½¬æ¢ä¸º API æ¨¡å‹
    apiMemo := convertMemoFromStore(storeMemo)

    // æ·»åŠ åˆ†ç±»ä¿¡æ¯ - åªæœ‰åˆ›å»ºè€…å¯è§
    currentUser, _ := s.getCurrentUser(ctx)
    if currentUser != nil && currentUser.ID == storeMemo.CreatorID && storeMemo.CategoryID != nil {
        category, err := s.Store.GetCategory(ctx, &store.FindCategory{
            ID:        storeMemo.CategoryID,
            RowStatus: &store.Normal,
        })
        if err == nil {
            apiMemo.Category = convertCategoryFromStore(category)
        }
    }

    return apiMemo, nil
}
```

#### å®ç° SetMemoCategory æ–¹æ³•
```go
func (s *MemoService) SetMemoCategory(ctx context.Context, req *apiv1pb.SetMemoCategoryRequest) (*emptypb.Empty, error) {
    // 1. è·å– memo ä¿¡æ¯
    memo, err := s.getMemoByName(ctx, req.Name)
    if err != nil {
        return nil, err
    }

    // 2. æƒé™éªŒè¯ - åªæœ‰åˆ›å»ºè€…å¯ä»¥è®¾ç½®åˆ†ç±»
    user, err := s.getCurrentUser(ctx)
    if err != nil {
        return nil, status.Errorf(codes.Unauthenticated, "failed to get current user")
    }
    if memo.CreatorID != user.ID {
        return nil, status.Errorf(codes.PermissionDenied, "only memo creator can set category")
    }

    // 3. å¤„ç†åˆ†ç±»è®¾ç½®
    var categoryID *int32
    if req.Category != nil && *req.Category != "" {
        id, err := extractCategoryID(*req.Category)
        if err != nil {
            return nil, status.Errorf(codes.InvalidArgument, "invalid category: %v", err)
        }

        // éªŒè¯åˆ†ç±»å­˜åœ¨ä¸”å±äºå½“å‰ç”¨æˆ·
        category, err := s.Store.GetCategory(ctx, &store.FindCategory{
            ID:        &id,
            CreatorID: &user.ID,
            RowStatus: &store.Normal,
        })
        if err != nil {
            return nil, status.Errorf(codes.NotFound, "category not found or access denied")
        }

        categoryID = &category.ID
    }

    // 4. æ›´æ–° memo åˆ†ç±»
    now := time.Now().Unix()
    _, err = s.Store.UpdateMemo(ctx, &store.UpdateMemo{
        ID:         memo.ID,
        CategoryID: categoryID,
        UpdatedTs:  &now,
    })
    if err != nil {
        return nil, status.Errorf(codes.Internal, "failed to update memo category")
    }

    return &emptypb.Empty{}, nil
}
```

#### ä¸ºä»€ä¹ˆå•ç‹¬å®ç° SetMemoCategoryï¼Ÿ
- **åŸå­æ“ä½œ**ï¼šåˆ†ç±»è®¾ç½®æ˜¯ç‹¬ç«‹çš„ä¸šåŠ¡æ“ä½œ
- **æƒé™æ¸…æ™°**ï¼šå•ç‹¬çš„æƒé™éªŒè¯é€»è¾‘
- **å®¡è®¡å‹å¥½**ï¼šä¾¿äºè®°å½•åˆ†ç±»å˜æ›´æ“ä½œ
- **API è¯­ä¹‰**ï¼šRESTful è¯­ä¹‰æ›´æ¸…æ™°

### æ•°æ®è½¬æ¢å‡½æ•°

#### Store åˆ° API æ¨¡å‹è½¬æ¢
```go
// éµå¾ªç°æœ‰çš„è½¬æ¢å‡½æ•°å‘½åå’Œå®ç°æ¨¡å¼
func convertCategoryFromStore(category *store.Category) *apiv1pb.Category {
    apiCategory := &apiv1pb.Category{
        Name:        fmt.Sprintf("categories/%d", category.ID),
        DisplayName: category.Name,
        Path:        category.Path,
        Color:       category.Color,
        Icon:        category.Icon,
        CreateTime:  timestamppb.New(time.Unix(category.CreatedTs, 0)),
        UpdateTime:  timestamppb.New(time.Unix(category.UpdatedTs, 0)),
    }

    // å¤„ç†çˆ¶åˆ†ç±»å¼•ç”¨
    if category.ParentID != nil {
        parent := fmt.Sprintf("categories/%d", *category.ParentID)
        apiCategory.Parent = &parent
    }

    return apiCategory
}

// èµ„æºåç§°è§£æå‡½æ•°
func extractCategoryID(name string) (int32, error) {
    if !strings.HasPrefix(name, "categories/") {
        return 0, errors.New("invalid category name format")
    }
    
    idStr := strings.TrimPrefix(name, "categories/")
    id, err := strconv.ParseInt(idStr, 10, 32)
    if err != nil {
        return 0, errors.New("invalid category ID")
    }
    
    return int32(id), nil
}
```

## å‰ç«¯å®ç°ç­–ç•¥

### çŠ¶æ€ç®¡ç†è®¾è®¡

#### éµå¾ªç°æœ‰ Store è®¾è®¡æ¨¡å¼
```typescript
// web/src/stores/v1/category.ts - éµå¾ªç°æœ‰ store å‘½åè§„èŒƒ
class CategoryState {
  // éµå¾ªç°æœ‰çš„çŠ¶æ€ ID æ¨¡å¼ï¼Œç”¨äºè§¦å‘é‡æ–°æ¸²æŸ“
  stateId: string = uniqueId();
  
  // æ‰å¹³åŒ–å­˜å‚¨åˆ†ç±»æ•°æ®ï¼Œéµå¾ªç°æœ‰çš„ Record æ¨¡å¼
  categoryMapByName: Record<string, Category> = {};
  
  // å½“å‰é€‰ä¸­çš„åˆ†ç±»ï¼Œç”¨äºç­›é€‰
  selectedCategoryName?: string;
  
  // è¯·æ±‚æ§åˆ¶ï¼Œéµå¾ªç°æœ‰çš„ AbortController æ¨¡å¼
  currentRequest: AbortController | null = null;

  constructor() {
    makeAutoObservable(this);
  }

  // éµå¾ªç°æœ‰çš„çŠ¶æ€æ›´æ–°æ¨¡å¼
  setPartial(partial: Partial<CategoryState>) {
    Object.assign(this, partial);
  }
  
  // è·å–åˆ†ç±»åˆ—è¡¨
  get categories(): Category[] {
    return Object.values(this.categoryMapByName);
  }
  
  // æ„å»ºåˆ†ç±»æ ‘ - æ€§èƒ½ä¼˜åŒ–çš„è®¡ç®—å±æ€§
  get categoryTree(): CategoryTreeNode[] {
    const rootCategories = this.categories.filter(cat => !cat.parent);
    return rootCategories
      .sort((a, b) => a.displayName.localeCompare(b.displayName))
      .map(cat => this.buildCategoryNode(cat));
  }
  
  private buildCategoryNode(category: Category): CategoryTreeNode {
    const children = this.categories
      .filter(cat => cat.parent === category.name)
      .sort((a, b) => a.displayName.localeCompare(b.displayName))
      .map(child => this.buildCategoryNode(child));

    return {
      category,
      children,
      expanded: true, // é»˜è®¤å±•å¼€ï¼Œå¯ä»¥æ‰©å±•ä¸ºæŒä¹…åŒ–çŠ¶æ€
    };
  }
}
```

#### ä¸ºä»€ä¹ˆä½¿ç”¨æ‰å¹³åŒ–å­˜å‚¨ï¼Ÿ
éµå¾ªç°æœ‰é¡¹ç›®çš„è®¾è®¡æ¨¡å¼ï¼š
- **æ›´æ–°ç®€å•**ï¼šé¿å…æ·±å±‚åµŒå¥—æ›´æ–°çš„å¤æ‚æ€§
- **æŸ¥æ‰¾é«˜æ•ˆ**ï¼šé€šè¿‡ name ç›´æ¥ç´¢å¼•ï¼ŒO(1) æŸ¥æ‰¾
- **ç¼“å­˜å‹å¥½**ï¼šå•ä¸€æ•°æ®æºï¼Œé¿å…æ•°æ®åŒæ­¥é—®é¢˜

#### ä¸ Memo Store çš„é›†æˆ
```typescript
// web/src/stores/v1/memo.ts - åœ¨ç°æœ‰ MemoState ä¸­æ·»åŠ åˆ†ç±»ç­›é€‰
class MemoState {
  // ... ç°æœ‰æ‰€æœ‰å­—æ®µä¿æŒä¸å˜

  // æ–°å¢åˆ†ç±»ç­›é€‰çŠ¶æ€
  selectedCategoryName?: string;
  includeSubcategories: boolean = false;

  // æ‰©å±•ç°æœ‰çš„è¿‡æ»¤é€»è¾‘
  get filteredMemos(): Memo[] {
    let memos = Object.values(this.memoMapByName);

    // ç°æœ‰çš„è¿‡æ»¤é€»è¾‘ä¿æŒä¸å˜
    // ...

    // æ–°å¢åˆ†ç±»è¿‡æ»¤
    if (this.selectedCategoryName) {
      if (this.includeSubcategories) {
        // è·å–å­åˆ†ç±» IDs
        const categoryStore = globalStore.categoryStore;
        const subcategoryNames = this.getSubcategoryNames(this.selectedCategoryName, categoryStore);
        
        memos = memos.filter(memo => 
          memo.category && 
          (memo.category.name === this.selectedCategoryName || 
           subcategoryNames.includes(memo.category.name))
        );
      } else {
        memos = memos.filter(memo => memo.category?.name === this.selectedCategoryName);
      }
    }

    return memos;
  }

  private getSubcategoryNames(categoryName: string, categoryStore: CategoryState): string[] {
    // é€’å½’è·å–å­åˆ†ç±»åç§°
    const category = categoryStore.categoryMapByName[categoryName];
    if (!category) return [];

    const subcategoryNames: string[] = [];
    const collectSubcategories = (catName: string) => {
      const children = categoryStore.categories.filter(cat => cat.parent === catName);
      children.forEach(child => {
        subcategoryNames.push(child.name);
        collectSubcategories(child.name);
      });
    };

    collectSubcategories(categoryName);
    return subcategoryNames;
  }
}
```

### API è°ƒç”¨å®ç°

#### éµå¾ªç°æœ‰çš„ API è°ƒç”¨æ¨¡å¼
```typescript
// web/src/stores/v1/category.ts - API è°ƒç”¨æ–¹æ³•
class CategoryState {
  // ... å…¶ä»–ä»£ç 

  async fetchCategories() {
    // éµå¾ªç°æœ‰çš„è¯·æ±‚å–æ¶ˆæ¨¡å¼
    if (this.currentRequest) {
      this.currentRequest.abort();
    }

    const controller = new AbortController();
    this.setPartial({ currentRequest: controller });

    try {
      const { categories } = await categoryServiceClient.listCategories(
        {},
        { signal: controller.signal }
      );

      // æ›´æ–°åˆ†ç±»æ˜ å°„
      const categoryMap: Record<string, Category> = {};
      for (const category of categories) {
        categoryMap[category.name] = category;
      }

      this.setPartial({
        stateId: uniqueId(),
        categoryMapByName: categoryMap,
      });
    } catch (error: any) {
      if (error.name === "AbortError") return;
      console.error("Failed to fetch categories:", error);
      throw error;
    } finally {
      if (this.currentRequest === controller) {
        this.setPartial({ currentRequest: null });
      }
    }
  }

  async createCategory(request: CreateCategoryRequest): Promise<Category> {
    const category = await categoryServiceClient.createCategory(request);
    
    // æ›´æ–°æœ¬åœ°çŠ¶æ€
    this.setPartial({
      stateId: uniqueId(),
      categoryMapByName: {
        ...this.categoryMapByName,
        [category.name]: category,
      },
    });

    return category;
  }

  async setMemoCategory(memoName: string, categoryName?: string) {
    await memoServiceClient.setMemoCategory({
      name: memoName,
      category: categoryName,
    });

    // è§¦å‘ memo store é‡æ–°è·å–æ•°æ®
    globalStore.memoStore.fetchMemos();
  }
}
```

### ç»„ä»¶å®ç°è¦ç‚¹

#### åˆ†ç±»æ ‘ç»„ä»¶è®¾è®¡
```tsx
// web/src/components/CategoryTree.tsx
interface CategoryTreeProps {
  categories: CategoryTreeNode[];
  selectedCategoryName?: string;
  onCategorySelect: (categoryName?: string) => void;
  onCategoryCreate?: (parent?: Category) => void;
  onCategoryEdit?: (category: Category) => void;
  onCategoryDelete?: (category: Category) => void;
}

export const CategoryTree: React.FC<CategoryTreeProps> = ({
  categories,
  selectedCategoryName,
  onCategorySelect,
  onCategoryCreate,
  onCategoryEdit,
  onCategoryDelete,
}) => {
  return (
    <div className="category-tree space-y-1">
      {/* "å…¨éƒ¨ç¬”è®°" é€‰é¡¹ */}
      <div 
        className={cn(
          "category-item",
          !selectedCategoryName && "category-item-selected"
        )}
        onClick={() => onCategorySelect(undefined)}
      >
        <Folder className="w-4 h-4" />
        <span>All Memos</span>
      </div>
      
      {/* åˆ†ç±»æ ‘èŠ‚ç‚¹ */}
      {categories.map(node => (
        <CategoryTreeNode
          key={node.category.name}
          node={node}
          level={0}
          selectedCategoryName={selectedCategoryName}
          onCategorySelect={onCategorySelect}
          onCategoryEdit={onCategoryEdit}
          onCategoryDelete={onCategoryDelete}
        />
      ))}
      
      {/* åˆ›å»ºåˆ†ç±»æŒ‰é’® */}
      {onCategoryCreate && (
        <Button
          variant="ghost"
          size="sm"
          className="category-item category-item-action"
          onClick={() => onCategoryCreate()}
        >
          <Plus className="w-4 h-4" />
          <span>New Category</span>
        </Button>
      )}
    </div>
  );
};
```

#### ä¸ºä»€ä¹ˆè¿™æ ·è®¾è®¡ç»„ä»¶æ¥å£ï¼Ÿ
- **åŠŸèƒ½åˆ†ç¦»**ï¼šæ¯ä¸ªå›è°ƒå‡½æ•°èŒè´£å•ä¸€
- **å¯é€‰å±æ€§**ï¼šæ”¯æŒåªè¯»å’Œå¯ç¼–è¾‘ä¸¤ç§æ¨¡å¼
- **ä¸€è‡´æ€§**ï¼šä¸ç°æœ‰ç»„ä»¶çš„æ¥å£è®¾è®¡ä¿æŒä¸€è‡´

#### åˆ†ç±»é€‰æ‹©å™¨ç»„ä»¶
```tsx
// web/src/components/CategorySelector.tsx
interface CategorySelectorProps {
  value?: Category;
  categories: Category[];
  onChange: (category?: Category) => void;
  placeholder?: string;
  disabled?: boolean;
}

export const CategorySelector: React.FC<CategorySelectorProps> = ({
  value,
  categories,
  onChange,
  placeholder = "Select category...",
  disabled = false,
}) => {
  const [open, setOpen] = useState(false);

  // æ„å»ºæ‰å¹³åŒ–çš„åˆ†ç±»åˆ—è¡¨ï¼Œä¿æŒå±‚çº§ä¿¡æ¯
  const flatCategories = useMemo(() => {
    const categoryTree = buildCategoryTree(categories);
    return flattenCategoryTree(categoryTree);
  }, [categories]);

  return (
    <Popover open={open} onOpenChange={setOpen}>
      <PopoverTrigger asChild>
        <Button
          variant="outline"
          role="combobox"
          aria-expanded={open}
          disabled={disabled}
          className="justify-between"
        >
          {value ? (
            <div className="flex items-center gap-2">
              <span style={{ color: value.color }}>{value.icon}</span>
              <span className="truncate">{value.path}</span>
            </div>
          ) : (
            <span className="text-muted-foreground">{placeholder}</span>
          )}
          <ChevronsUpDown className="ml-2 h-4 w-4 shrink-0 opacity-50" />
        </Button>
      </PopoverTrigger>
      
      <PopoverContent className="w-80 p-0">
        <Command>
          <CommandInput placeholder="Search categories..." />
          <CommandEmpty>No category found.</CommandEmpty>
          <CommandGroup max-height="200px">
            {/* "æ— åˆ†ç±»" é€‰é¡¹ */}
            <CommandItem
              onSelect={() => {
                onChange(undefined);
                setOpen(false);
              }}
            >
              <Check
                className={cn(
                  "mr-2 h-4 w-4",
                  !value ? "opacity-100" : "opacity-0"
                )}
              />
              <span className="text-muted-foreground">No category</span>
            </CommandItem>
            
            {/* åˆ†ç±»é€‰é¡¹ */}
            {flatCategories.map(({ category, level }) => (
              <CommandItem
                key={category.name}
                onSelect={() => {
                  onChange(category);
                  setOpen(false);
                }}
              >
                <Check
                  className={cn(
                    "mr-2 h-4 w-4",
                    value?.name === category.name ? "opacity-100" : "opacity-0"
                  )}
                />
                <div 
                  className="flex items-center gap-2 min-w-0 flex-1"
                  style={{ paddingLeft: `${level * 12}px` }}
                >
                  <span style={{ color: category.color }}>{category.icon}</span>
                  <span className="truncate">{category.displayName}</span>
                </div>
              </CommandItem>
            ))}
          </CommandGroup>
        </Command>
      </PopoverContent>
    </Popover>
  );
};
```

### éšç§ä¿æŠ¤çš„å®ç°

#### æ¡ä»¶æ¸²æŸ“ç­–ç•¥
```tsx
// web/src/components/MemoCard.tsx - æ‰©å±•ç°æœ‰ MemoCard ç»„ä»¶
export const MemoCard: React.FC<MemoCardProps> = ({ memo }) => {
  const { userStore } = useGlobalStore();
  
  // æ£€æŸ¥æ˜¯å¦ä¸ºåˆ›å»ºè€… - éµå¾ªç°æœ‰çš„æƒé™æ£€æŸ¥æ¨¡å¼
  const isCreator = userStore.currentUser?.name === memo.creator;
  const showPrivateMetadata = isCreator;

  return (
    <Card className="memo-card">
      {/* åˆ†ç±»ä¿¡æ¯ - åªæœ‰åˆ›å»ºè€…å¯è§ */}
      {showPrivateMetadata && memo.category && (
        <div className="memo-category-breadcrumb">
          <CategoryBreadcrumb category={memo.category} />
        </div>
      )}

      {/* memo å†…å®¹ - ç°æœ‰é€»è¾‘ä¿æŒä¸å˜ */}
      <div className="memo-content">
        <MemoContent content={memo.content} />
      </div>

      {/* å…ƒä¿¡æ¯åŒºåŸŸ */}
      <div className="memo-meta">
        <div className="memo-timestamps">
          <time>{formatDateTime(memo.createTime)}</time>
          {showPrivateMetadata && memo.updateTime && (
            <span className="text-muted-foreground text-sm">
              Â· Updated {formatRelativeTime(memo.updateTime)}
            </span>
          )}
        </div>

        {/* æ ‡ç­¾ - å§‹ç»ˆå¯è§ */}
        {memo.tags.length > 0 && (
          <div className="memo-tags">
            {memo.tags.map(tag => (
              <Badge key={tag} variant="secondary">#{tag}</Badge>
            ))}
          </div>
        )}

        {/* ç§æœ‰å…ƒæ•°æ® - åªæœ‰åˆ›å»ºè€…å¯è§ */}
        {showPrivateMetadata && (
          <div className="memo-private-meta">
            <VisibilityBadge visibility={memo.visibility} />
          </div>
        )}
      </div>
    </Card>
  );
};
```

#### ä¸ºä»€ä¹ˆè¿™æ ·å®ç°éšç§ä¿æŠ¤ï¼Ÿ
- **ä¸€è‡´æ€§æ£€æŸ¥**ï¼šä½¿ç”¨ç»Ÿä¸€çš„ `isCreator` é€»è¾‘
- **é»˜è®¤éšè—**ï¼šé»˜è®¤ä¸æ˜¾ç¤ºåˆ†ç±»ä¿¡æ¯ï¼Œåªåœ¨ç¡®è®¤æƒé™åæ˜¾ç¤º
- **æ¸…æ™°åˆ†ç¦»**ï¼šç§æœ‰å…ƒæ•°æ®å’Œå…¬å…±ä¿¡æ¯æ˜ç¡®åˆ†ç¦»

## æ•°æ®åº“è¿ç§»å®ç°

### éµå¾ªç°æœ‰è¿ç§»æ¨¡å¼

#### è¿ç§»æ–‡ä»¶ç»„ç»‡
```
store/migration/
â”œâ”€â”€ sqlite/
â”‚   â””â”€â”€ 0.23/  # å‡è®¾å½“å‰ç‰ˆæœ¬æ˜¯ 0.22
â”‚       â”œâ”€â”€ 00__category_table.sql
â”‚       â”œâ”€â”€ 01__memo_category_field.sql
â”‚       â””â”€â”€ 02__category_indexes.sql
â”œâ”€â”€ postgres/
â”‚   â””â”€â”€ 0.23/
â”‚       â”œâ”€â”€ 00__category_table.sql
â”‚       â”œâ”€â”€ 01__memo_category_field.sql
â”‚       â””â”€â”€ 02__category_indexes.sql
â””â”€â”€ mysql/
    â””â”€â”€ 0.23/
        â”œâ”€â”€ 00__category_table.sql
        â”œâ”€â”€ 01__memo_category_field.sql
        â””â”€â”€ 02__category_indexes.sql
```

#### SQLite è¿ç§»è„šæœ¬
```sql
-- store/migration/sqlite/0.23/00__category_table.sql
CREATE TABLE category (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  name TEXT NOT NULL CHECK (length(name) <= 100 AND length(name) > 0),
  path TEXT NOT NULL CHECK (length(path) <= 500 AND length(path) > 0),
  parent_id INTEGER REFERENCES category(id) ON DELETE CASCADE,
  creator_id INTEGER NOT NULL REFERENCES user(id) ON DELETE CASCADE,
  color TEXT NOT NULL DEFAULT '#6366f1' CHECK (color REGEXP '^#[0-9A-Fa-f]{6}$'),
  icon TEXT NOT NULL DEFAULT 'ğŸ“' CHECK (length(icon) <= 20),
  created_ts BIGINT NOT NULL DEFAULT (strftime('%s', 'now')),
  updated_ts BIGINT NOT NULL DEFAULT (strftime('%s', 'now')),
  row_status TEXT NOT NULL DEFAULT 'NORMAL' CHECK (row_status IN ('NORMAL', 'ARCHIVED'))
);

-- store/migration/sqlite/0.23/01__memo_category_field.sql
ALTER TABLE memo ADD COLUMN category_id INTEGER REFERENCES category(id) ON DELETE SET NULL;

-- store/migration/sqlite/0.23/02__category_indexes.sql
CREATE INDEX idx_category_creator_id ON category(creator_id) WHERE row_status = 'NORMAL';
CREATE INDEX idx_category_parent_id ON category(parent_id) WHERE row_status = 'NORMAL';
CREATE UNIQUE INDEX idx_category_path_creator ON category(path, creator_id) WHERE row_status = 'NORMAL';
CREATE INDEX idx_memo_category_id ON memo(category_id) WHERE row_status = 'NORMAL';
```

#### ä¸ºä»€ä¹ˆåˆ†æˆå¤šä¸ªæ–‡ä»¶ï¼Ÿ
éµå¾ªç°æœ‰é¡¹ç›®çš„æœ€ä½³å®è·µï¼š
- **åŸå­æ“ä½œ**ï¼šæ¯ä¸ªæ–‡ä»¶ä»£è¡¨ä¸€ä¸ªé€»è¾‘å•å…ƒ
- **å®¹é”™æ€§**ï¼šå•ä¸ªæ“ä½œå¤±è´¥ä¸å½±å“å…¶ä»–æ“ä½œ
- **å¯è¯»æ€§**ï¼šæ–‡ä»¶åæ¸…æ¥šè¡¨æ˜æ“ä½œå†…å®¹
- **ç‰ˆæœ¬æ§åˆ¶**ï¼šä¾¿äºè·Ÿè¸ªç‰¹å®šå˜æ›´

#### PostgreSQL é€‚é…
```sql
-- store/migration/postgres/0.23/00__category_table.sql
CREATE TABLE category (
  id SERIAL PRIMARY KEY,
  name VARCHAR(100) NOT NULL CHECK (length(name) > 0),
  path VARCHAR(500) NOT NULL CHECK (length(path) > 0),
  parent_id INTEGER REFERENCES category(id) ON DELETE CASCADE,
  creator_id INTEGER NOT NULL REFERENCES "user"(id) ON DELETE CASCADE,
  color VARCHAR(7) NOT NULL DEFAULT '#6366f1' CHECK (color ~ '^#[0-9A-Fa-f]{6}$'),
  icon VARCHAR(20) NOT NULL DEFAULT 'ğŸ“',
  created_ts BIGINT NOT NULL DEFAULT EXTRACT(epoch FROM NOW()),
  updated_ts BIGINT NOT NULL DEFAULT EXTRACT(epoch FROM NOW()),
  row_status VARCHAR(20) NOT NULL DEFAULT 'NORMAL' CHECK (row_status IN ('NORMAL', 'ARCHIVED'))
);
```

#### æ•°æ®åº“å·®å¼‚å¤„ç†è¦ç‚¹
- **ä¸»é”®ç”Ÿæˆ**ï¼šSQLite ä½¿ç”¨ `AUTOINCREMENT`ï¼ŒPostgreSQL ä½¿ç”¨ `SERIAL`
- **æ­£åˆ™è¡¨è¾¾å¼**ï¼šSQLite ä½¿ç”¨ `REGEXP`ï¼ŒPostgreSQL ä½¿ç”¨ `~`
- **æ—¶é—´æˆ³**ï¼šä¸åŒæ•°æ®åº“çš„æ—¶é—´å‡½æ•°å·®å¼‚
- **å…³é”®å­—è½¬ä¹‰**ï¼šPostgreSQL çš„ `user` éœ€è¦å¼•å·

## æµ‹è¯•ç­–ç•¥

### éµå¾ªç°æœ‰æµ‹è¯•æ¨¡å¼

#### Store å±‚æµ‹è¯•
```go
// store/test/category_test.go
func TestCategoryStore(t *testing.T) {
    ctx := context.Background()
    ts := NewTestingStore(ctx, t)
    
    // åˆ›å»ºæµ‹è¯•ç”¨æˆ· - éµå¾ªç°æœ‰æµ‹è¯•æ•°æ®åˆ›å»ºæ¨¡å¼
    user, err := createTestingHostUser(ctx, ts)
    require.NoError(t, err)

    t.Run("CreateCategory", func(t *testing.T) {
        category := &store.Category{
            Name:      "Work",
            CreatorID: user.ID,
            Color:     "#ff0000",
            Icon:      "ğŸ’¼",
            CreatedTs: time.Now().Unix(),
            UpdatedTs: time.Now().Unix(),
            RowStatus: store.Normal,
        }

        created, err := ts.CreateCategory(ctx, category)
        require.NoError(t, err)
        require.NotZero(t, created.ID)
        require.Equal(t, "Work", created.Name)
        require.Equal(t, "Work", created.Path) // æ ¹åˆ†ç±»è·¯å¾„ç­‰äºåç§°
        require.Nil(t, created.ParentID)
    })

    t.Run("CreateSubcategory", func(t *testing.T) {
        // å…ˆåˆ›å»ºçˆ¶åˆ†ç±»
        parent := &store.Category{
            Name:      "Projects",
            CreatorID: user.ID,
            CreatedTs: time.Now().Unix(),
            UpdatedTs: time.Now().Unix(),
            RowStatus: store.Normal,
        }
        parentCreated, err := ts.CreateCategory(ctx, parent)
        require.NoError(t, err)

        // åˆ›å»ºå­åˆ†ç±»
        child := &store.Category{
            Name:      "Mobile App",
            ParentID:  &parentCreated.ID,
            CreatorID: user.ID,
            CreatedTs: time.Now().Unix(),
            UpdatedTs: time.Now().Unix(),
            RowStatus: store.Normal,
        }
        childCreated, err := ts.CreateCategory(ctx, child)
        require.NoError(t, err)
        require.Equal(t, "Projects/Mobile App", childCreated.Path)
    })

    t.Run("PreventCircularReference", func(t *testing.T) {
        // æµ‹è¯•å¾ªç¯å¼•ç”¨æ£€æµ‹é€»è¾‘
        // ... æµ‹è¯•å®ç°
    })
}
```

#### API å±‚æµ‹è¯•
```go
// server/router/api/v1/test/category_service_test.go
func TestCategoryService(t *testing.T) {
    ctx := context.Background()
    s := NewTestService(ctx, t)
    
    // åˆ›å»ºæµ‹è¯•ç”¨æˆ·å’Œè®¤è¯ä¸Šä¸‹æ–‡
    user, err := createTestingAdminUser(ctx, s.Store)
    require.NoError(t, err)
    
    ctx = metadata.AppendToOutgoingContext(ctx, "authorization", "Bearer "+generateAccessToken(user.Username, user.ID, time.Hour, s.Secret))

    t.Run("CreateCategory", func(t *testing.T) {
        req := &apiv1pb.CreateCategoryRequest{
            Category: &apiv1pb.Category{
                DisplayName: "Work",
                Color:       "#ff0000",
                Icon:        "ğŸ’¼",
            },
        }

        category, err := s.CategoryService.CreateCategory(ctx, req)
        require.NoError(t, err)
        require.True(t, strings.HasPrefix(category.Name, "categories/"))
        require.Equal(t, "Work", category.DisplayName)
        require.Equal(t, "Work", category.Path)
    })

    t.Run("RequireAuthentication", func(t *testing.T) {
        // æµ‹è¯•æœªè®¤è¯è¯·æ±‚
        unauthCtx := context.Background()
        req := &apiv1pb.CreateCategoryRequest{
            Category: &apiv1pb.Category{DisplayName: "Test"},
        }

        _, err := s.CategoryService.CreateCategory(unauthCtx, req)
        require.Error(t, err)
        require.Equal(t, codes.Unauthenticated, status.Code(err))
    })
}
```

#### ä¸ºä»€ä¹ˆè¿™æ ·è®¾è®¡æµ‹è¯•ï¼Ÿ
- **æ•°æ®éš”ç¦»**ï¼šæ¯ä¸ªæµ‹è¯•ä½¿ç”¨ç‹¬ç«‹çš„æ•°æ®åº“å®ä¾‹
- **è®¤è¯æµ‹è¯•**ï¼šéªŒè¯æƒé™æ§åˆ¶çš„æ­£ç¡®æ€§
- **è¾¹ç•Œæµ‹è¯•**ï¼šæµ‹è¯•å„ç§è¾¹ç•Œæ¡ä»¶å’Œé”™è¯¯åœºæ™¯
- **ä¸€è‡´æ€§**ï¼šä¸ç°æœ‰æµ‹è¯•çš„é£æ ¼å’Œç»“æ„ä¿æŒä¸€è‡´

## æ€§èƒ½å’Œæ‰©å±•æ€§è€ƒè™‘

### æ€§èƒ½ä¼˜åŒ–ç­–ç•¥

#### 1. æŸ¥è¯¢ä¼˜åŒ–é™åˆ¶
åŸºäºå®é™…ä½¿ç”¨åœºæ™¯è®¾ç½®åˆç†é™åˆ¶ï¼š
- **åˆ†ç±»æ·±åº¦é™åˆ¶**ï¼šæœ€å¤§ 10 çº§ï¼Œé˜²æ­¢æ¶æ„æ·±åº¦åµŒå¥—
- **åˆ†ç±»æ•°é‡é™åˆ¶**ï¼šå•ç”¨æˆ·æœ€å¤§ 1000 ä¸ªåˆ†ç±»
- **è·¯å¾„é•¿åº¦é™åˆ¶**ï¼šæœ€å¤§ 500 å­—ç¬¦ï¼Œé˜²æ­¢è¿‡é•¿è·¯å¾„
- **æ‰¹é‡æ“ä½œé™åˆ¶**ï¼šå•æ¬¡æœ€å¤§æ“ä½œ 100 ä¸ªåˆ†ç±»

#### 2. ç¼“å­˜ç­–ç•¥
```go
// store/cache.go - æ‰©å±•ç°æœ‰ç¼“å­˜ç³»ç»Ÿ
type CategoryCache struct {
    // ç”¨æˆ·åˆ†ç±»æ ‘ç¼“å­˜ï¼ŒTTL 30åˆ†é’Ÿ
    userTreeCache *cache.Cache[string, []*Category]
    
    // åˆ†ç±»è·¯å¾„ç¼“å­˜ï¼ŒTTL 1å°æ—¶
    pathCache *cache.Cache[int32, string]
}

func (c *CategoryCache) GetUserCategoryTree(userID int32) ([]*Category, bool) {
    key := fmt.Sprintf("user:%d:tree", userID)
    return c.userTreeCache.Get(key)
}

func (c *CategoryCache) InvalidateUserCache(userID int32) {
    key := fmt.Sprintf("user:%d:tree", userID)
    c.userTreeCache.Delete(key)
}
```

#### ä¸ºä»€ä¹ˆè¿™æ ·è®¾è®¡ç¼“å­˜ï¼Ÿ
- **ç”¨æˆ·éš”ç¦»**ï¼šæ¯ä¸ªç”¨æˆ·çš„åˆ†ç±»æ ‘ç‹¬ç«‹ç¼“å­˜
- **é€‚åº¦ TTL**ï¼šå¹³è¡¡æ•°æ®æ–°é²œåº¦å’Œæ€§èƒ½
- **é€‰æ‹©æ€§å¤±æ•ˆ**ï¼šåªåœ¨å¿…è¦æ—¶æ¸…ç†ç›¸å…³ç¼“å­˜

#### 3. æ•°æ®åº“ä¼˜åŒ–
```sql
-- åŸºäºæŸ¥è¯¢æ¨¡å¼ä¼˜åŒ–çš„ç´¢å¼•ç­–ç•¥
-- é¢‘ç¹æŸ¥è¯¢ï¼šæŒ‰ç”¨æˆ·åˆ—å‡ºåˆ†ç±»
CREATE INDEX idx_category_creator_status ON category(creator_id, row_status);

-- ä¸­ç­‰é¢‘ç‡ï¼šæ„å»ºåˆ†ç±»æ ‘
CREATE INDEX idx_category_parent_creator ON category(parent_id, creator_id) WHERE row_status = 'NORMAL';

-- ä½é¢‘æŸ¥è¯¢ï¼šæŒ‰è·¯å¾„æŸ¥æ‰¾åˆ†ç±»ï¼ˆä¸»è¦ç”¨äºå»é‡ï¼‰
CREATE INDEX idx_category_path_hash ON category(substr(path, 1, 100)) WHERE row_status = 'NORMAL';
```

### æ‰©å±•æ€§è®¾è®¡

#### 1. åˆ†ç±»å±æ€§æ‰©å±•
é¢„ç•™æ‰©å±•å­—æ®µï¼Œæ”¯æŒæœªæ¥åŠŸèƒ½ï¼š
```go
// æœªæ¥å¯èƒ½çš„æ‰©å±•å­—æ®µ
type Category struct {
    // ... ç°æœ‰å­—æ®µ
    
    // æ‰©å±•å±æ€§ï¼ˆå­˜å‚¨ JSONï¼‰
    Metadata map[string]interface{} `json:"metadata,omitempty"`
    
    // æ’åºæƒé‡
    SortOrder *int32 `json:"sort_order,omitempty"`
    
    // æè¿°ä¿¡æ¯
    Description *string `json:"description,omitempty"`
}
```

#### 2. æƒé™ç³»ç»Ÿæ‰©å±•
ä¸ºæœªæ¥çš„æƒé™ç»†åŒ–é¢„ç•™æ¥å£ï¼š
```go
// æƒé™æ£€æŸ¥æ¥å£ï¼Œå¯æ‰©å±•ä¸ºå¤æ‚æƒé™ç³»ç»Ÿ
type CategoryPermissionChecker interface {
    CanRead(ctx context.Context, userID int32, categoryID int32) (bool, error)
    CanWrite(ctx context.Context, userID int32, categoryID int32) (bool, error)
    CanDelete(ctx context.Context, userID int32, categoryID int32) (bool, error)
}
```

#### 3. å¤šç§Ÿæˆ·æ”¯æŒ
è™½ç„¶å½“å‰æ˜¯å•ç§Ÿæˆ·ï¼Œä½†è®¾è®¡ä¸Šæ”¯æŒæœªæ¥çš„å¤šç§Ÿæˆ·æ‰©å±•ï¼š
- **å·¥ä½œç©ºé—´éš”ç¦»**ï¼šé€šè¿‡ `creator_id` å¤©ç„¶å®ç°ç”¨æˆ·æ•°æ®éš”ç¦»
- **èµ„æºå‘½å**ï¼šæ”¯æŒæ‰©å±•ä¸º `workspaces/{workspace}/categories/{category}`
- **æƒé™è¾¹ç•Œ**ï¼šç”¨æˆ·åªèƒ½è®¿é—®è‡ªå·±åˆ›å»ºçš„åˆ†ç±»

## å®æ–½è®¡åˆ’

### ç¬¬ä¸€é˜¶æ®µï¼šæ ¸å¿ƒåŠŸèƒ½ï¼ˆ2-3 å‘¨ï¼‰
1. **æ•°æ®åº“å±‚**ï¼šåˆ›å»ºè¿ç§»è„šæœ¬ï¼Œå»ºç«‹åŸºç¡€è¡¨ç»“æ„
2. **Store å±‚**ï¼šå®ç°åŸºç¡€ CRUD æ“ä½œå’ŒæŸ¥è¯¢é€»è¾‘
3. **Proto å®šä¹‰**ï¼šå®šä¹‰ API æ¥å£å’Œæ•°æ®æ¨¡å‹
4. **åŸºç¡€æµ‹è¯•**ï¼šStore å±‚å’Œæ•°æ®åº“å±‚æµ‹è¯•

### ç¬¬äºŒé˜¶æ®µï¼šAPI é›†æˆï¼ˆ2-3 å‘¨ï¼‰
1. **CategoryService**ï¼šå®ç°å®Œæ•´çš„åˆ†ç±»ç®¡ç† API
2. **MemoService æ‰©å±•**ï¼šå®ç°åˆ†ç±»åˆ†é…å’ŒæŸ¥è¯¢åŠŸèƒ½
3. **æƒé™éªŒè¯**ï¼šç¡®ä¿åˆ†ç±»éšç§ä¿æŠ¤
4. **API æµ‹è¯•**ï¼šç«¯åˆ°ç«¯ API æµ‹è¯•

### ç¬¬ä¸‰é˜¶æ®µï¼šå‰ç«¯å®ç°ï¼ˆ3-4 å‘¨ï¼‰
1. **çŠ¶æ€ç®¡ç†**ï¼šå®ç°åˆ†ç±» Store å’Œ API è°ƒç”¨
2. **åŸºç¡€ç»„ä»¶**ï¼šåˆ†ç±»æ ‘ã€åˆ†ç±»é€‰æ‹©å™¨ç­‰
3. **é›†æˆç•Œé¢**ï¼šå°†åˆ†ç±»åŠŸèƒ½é›†æˆåˆ°ç°æœ‰ç•Œé¢
4. **ç”¨æˆ·ä½“éªŒ**ï¼šå“åº”å¼è®¾è®¡å’Œäº¤äº’ä¼˜åŒ–

### ç¬¬å››é˜¶æ®µï¼šå®Œå–„å’Œä¼˜åŒ–ï¼ˆ1-2 å‘¨ï¼‰
1. **æ€§èƒ½ä¼˜åŒ–**ï¼šç¼“å­˜ç­–ç•¥å’ŒæŸ¥è¯¢ä¼˜åŒ–
2. **é”™è¯¯å¤„ç†**ï¼šå®Œå–„é”™è¯¯åœºæ™¯å¤„ç†
3. **æ–‡æ¡£æ›´æ–°**ï¼šAPI æ–‡æ¡£å’Œç”¨æˆ·æ–‡æ¡£
4. **å‘å¸ƒå‡†å¤‡**ï¼šæµ‹è¯•å’Œéƒ¨ç½²è„šæœ¬

### é£é™©æ§åˆ¶æªæ–½
1. **æ¸è¿›å‘å¸ƒ**ï¼šé€šè¿‡åŠŸèƒ½å¼€å…³æ§åˆ¶åŠŸèƒ½ä¸Šçº¿
2. **å‘åå…¼å®¹**ï¼šç¡®ä¿ç°æœ‰åŠŸèƒ½ä¸å—å½±å“
3. **æ•°æ®ä¿æŠ¤**ï¼šè¿ç§»è¿‡ç¨‹ä¸­çš„æ•°æ®å¤‡ä»½å’Œå›æ»š
4. **æ€§èƒ½ç›‘æ§**ï¼šå…³é”®æŒ‡æ ‡çš„ç›‘æ§å’ŒæŠ¥è­¦

## æ€»ç»“

è¿™ä¸ªåˆ†ç±»ç³»ç»Ÿè®¾è®¡ä¸¥æ ¼éµå¾ª memos é¡¹ç›®çš„ç°æœ‰æ¶æ„æ¨¡å¼ï¼Œç¡®ä¿ä»£ç ä¸€è‡´æ€§å’Œå¯ç»´æŠ¤æ€§ã€‚ä¸»è¦ç‰¹ç‚¹ï¼š

### è®¾è®¡äº®ç‚¹
1. **æ¶æ„ä¸€è‡´æ€§**ï¼šä¸¥æ ¼éµå¾ªå››å±‚æ¶æ„å’Œç°æœ‰è®¾è®¡æ¨¡å¼
2. **éšç§ä¿æŠ¤**ï¼šåˆ†ç±»ä½œä¸ºç§æœ‰å…ƒæ•°æ®ï¼Œç¡®ä¿ç”¨æˆ·éšç§
3. **æ¸è¿›é›†æˆ**ï¼šæœ€å°ä¾µå…¥ç°æœ‰ç³»ç»Ÿï¼Œæ”¯æŒé€æ­¥é‡‡ç”¨
4. **æ€§èƒ½ä¼˜å…ˆ**ï¼šåˆç†çš„ç¼“å­˜ç­–ç•¥å’ŒæŸ¥è¯¢ä¼˜åŒ–
5. **æ‰©å±•å‹å¥½**ï¼šé¢„ç•™æ‰©å±•ç©ºé—´ï¼Œæ”¯æŒæœªæ¥åŠŸèƒ½å‡çº§

### æŠ€æœ¯å†³ç­–
1. **è·¯å¾„å†—ä½™å­˜å‚¨**ï¼šç‰ºç‰²å­˜å‚¨ç©ºé—´æ¢å–æŸ¥è¯¢æ€§èƒ½
2. **ç”¨æˆ·æ•°æ®éš”ç¦»**ï¼šé€šè¿‡ creator_id å®ç°ä¸¥æ ¼çš„æƒé™æ§åˆ¶
3. **å•ä¸€åˆ†ç±»çº¦æŸ**ï¼šé€šè¿‡æ•°æ®åº“è®¾è®¡å¼ºåˆ¶ä¸šåŠ¡è§„åˆ™
4. **æ ‡å‡†å­—æ®µç»„**ï¼šéµå¾ªé¡¹ç›®æ—¢å®šçš„æ—¶é—´æˆ³å’ŒçŠ¶æ€ç®¡ç†æ¨¡å¼

### å®æ–½ä¿éšœ
1. **å…¨é¢æµ‹è¯•**ï¼šStoreã€APIã€å‰ç«¯ä¸‰å±‚æµ‹è¯•è¦†ç›–
2. **è¿ç§»å®‰å…¨**ï¼šåˆ†æ­¥éª¤æ•°æ®åº“è¿ç§»ï¼Œæ”¯æŒå›æ»š
3. **ç›‘æ§å®Œå–„**ï¼šå…³é”®æŒ‡æ ‡ç›‘æ§å’Œæ€§èƒ½è·Ÿè¸ª
4. **æ–‡æ¡£é½å…¨**ï¼šå¼€å‘æ–‡æ¡£å’Œç”¨æˆ·æ–‡æ¡£åŒæ­¥æ›´æ–°

è¿™ä¸ªè®¾è®¡æ—¢æ»¡è¶³äº†åˆ†ç±»ç³»ç»Ÿçš„åŠŸèƒ½éœ€æ±‚ï¼Œåˆä¿æŒäº†ä¸ç°æœ‰ç³»ç»Ÿçš„é«˜åº¦ä¸€è‡´æ€§ï¼Œä¸ºé¡¹ç›®çš„é•¿æœŸå‘å±•å¥ å®šäº†åšå®çš„åŸºç¡€ã€‚