# Memos 标签 API 重构设计

## 🎯 设计原则

1. **Tag 是运行时的量**：从 memo 内容解析出的结构化元数据，存储在 payload 中用于查询优化
2. **Tag 树包含 memo 关系**：每个 TagNode 包含使用它的所有 memo_ids，而非简单的引用计数
3. **生命周期由内容驱动**：标签完全由 memo 内容决定，无需手动创建
4. **支持层级查询**：前缀匹配实现高效的树形查询

## 🚨 破坏性修改概览

### 1. 调整现有 Memo 级别 Tag 操作

基于**单一职责原则**的最小修改：

- 🔧 **修改**: `RenameMemoTag` API - **移除全局重命名功能**，只保留单个 memo 操作
  - ❌ 不再支持 `parent = "memos/-"` 的全局重命名
  - 🔄 **替代方案**: 使用 `TagService.RenameTag` 进行全局标签重命名
  - ✅ 保留 `parent = "memos/{memo_id}"` 的单个 memo 重命名
- 🔧 **修改**: `DeleteMemoTag` API - **移除全局删除功能**，只保留单个 memo 操作
  - ❌ 不再支持 `parent = "memos/-"` 的全局删除
  - 🔄 **替代方案**: 使用 `TagService.DeleteTag` 删除全局标签，或使用 `MemoService.BatchDeleteMemosByTag` 批量删除包含特定标签的 memos
  - ✅ 保留 `parent = "memos/{memo_id}"` 的单个 memo 标签删除
- ✅ **新增**: 专门的 `TagService` 处理全局标签操作

### 2. 数据模型增强
- ✅ **扩展**: `TagNode` 结构，支持层级路径和 memo 关联
- ✅ **新增**: 独立的 `TagService`，专门处理标签相关操作
- ✅ **新增**: 批量删除含特定标签的 memos 功能

## 📊 新的数据结构

### TagNode 增强 (`/proto/store/tag.proto`)

```protobuf
message TagNode {
  // The full hierarchical path (e.g., "/work/project1/backend")
  // 在树形标签系统中，name 字段自然演变为完整路径，作为标签的唯一标识符
  string name = 1;

  // 🚨 NEW: Path segments for efficient querying (e.g., ["work", "project1", "backend"])
  repeated string path_segments = 2;

  // 🚨 NEW: All memo IDs that use this tag
  repeated string memo_ids = 3;

  // 🚨 NEW: Creator for user isolation
  int32 creator_id = 4;
}
```

### 关键设计决策

#### 为什么保留 `name` 字段作为完整路径？

1. **语义一致**：`name` 字段一直是标签的标识符，在树形系统中自然演变为完整路径
2. **最小变更**：不需要重命名现有字段，减少破坏性修改
3. **向后兼容**：现有代码可以继续使用 `name` 字段
4. **计算显示名称**：叶子节点名称可以从 `path_segments` 的最后一个元素获得

#### 如何获取标签的显示名称？

```go
// 从 TagNode 计算显示名称
func (t *TagNode) GetDisplayName() string {
    if len(t.PathSegments) == 0 {
        return t.Name // fallback to full path
    }
    return t.PathSegments[len(t.PathSegments)-1] // 取最后一段
}

// 示例：
// name: "/work/project1/backend"
// path_segments: ["work", "project1", "backend"]
// display_name: "backend"
```

#### 为什么选择 memo_ids 而非 ref_count？

1. **更丰富的信息**：直接知道哪些 memo 使用了该标签
2. **支持复杂操作**：批量删除、标签重命名等操作可以直接获取影响的 memo 列表
3. **便于调试**：可以直接查看标签和内容的关联关系
4. **统计灵活性**：
   - `direct_memo_count = len(memo_ids)` - 直接使用该标签的数量
   - `total_memo_count` - 包括子标签的总数量

### 存储方案设计

**TagNode 继续存储在 memo payload 中**，原因如下：

#### ✅ 继续使用 JSON 存储的优势

1. **架构一致性**：
   - Memos 在 v0.22 明确选择了 payload 设计模式
   - 标签是从内容解析出的**元数据**，不是独立业务实体
   - 与现有 `property`、`location` 保持设计一致性

2. **现有查询性能优秀**：
   - SQLite: `JSON_EACH()` + `JSON_EXTRACT()` 有专门优化
   - MySQL: `JSON_SEARCH()` 比多表 JOIN 更高效
   - PostgreSQL: `jsonb` 支持 GIN 索引，查询性能强劲

3. **事务一致性天然保证**：
   - memo 内容和标签在同一行，原子更新
   - 避免分布式事务复杂性
   - 标签生命周期与 memo 自动同步

4. **开发简单性**：
   - 无需维护复杂的 memo-tag 关联表
   - 新增字段无需 ALTER TABLE
   - 减少数据不一致风险

#### TagNode 使用场景分层

**Memo Payload 存储**（精简版）
```json
// memo.payload 中存储结构化标签信息
{
  "payload": {
    "tags": [
      {
        "name": "/work/project1/backend",
        "path_segments": ["work", "project1", "backend"]
        // memo_ids 和 creator_id 不在这里存储，避免数据冗余
      }
    ]
  }
}
```

**TagService API 返回**（完整版）
```protobuf
// TagService 返回完整的 TagNode，包含聚合信息
message TagNode {
  string name = 1;                    // 完整路径
  repeated string path_segments = 2;  // 路径分段
  repeated string memo_ids = 3;       // 运行时聚合的 memo 列表
  int32 creator_id = 4;               // 从查询上下文推导
}
```
#### TagService 聚合逻辑

TagService 通过以下步骤实现标签的运行时聚合：

1. **查询用户 memos**：获取当前用户的所有 memos 及其 payload
2. **提取标签信息**：从每个 memo 的 payload.tags 中提取 TagNode
3. **聚合统计**：按 `name` 分组，收集使用该标签的所有 memo_ids
4. **计算层级关系**：基于 `path_segments` 构建父子关系和统计信息
5. **返回完整 TagNode**：包含 `memo_ids`、`creator_id` 等聚合信息

#### 数据库架构保持不变

```sql
-- memo 表结构保持现有设计
CREATE TABLE memo (
  ...
  payload TEXT NOT NULL DEFAULT '{}'  -- 继续使用 JSON 存储
);
```

#### 查询兼容性

现有的标签过滤语法完全兼容：
- `tag in ["work"]` → 匹配 `name` 字段包含 "work" 的标签
- 支持层级查询：`tag in ["/work"]` → 匹配所有 `/work/*` 路径
- 继续使用现有的 JSON 查询优化

## 🏗️ API 重构设计原则

### 核心设计原则

#### 1. 单一职责原则（Single Responsibility Principle）

我们将标签相关操作按照职责范围进行了彻底分离：

- **`MemoService.RenameMemoTag`** - 负责处理**单个备忘录**的标签重命名（移除全局功能）
- **`TagService.RenameTag`** - 负责处理**全局标签**的重命名操作
- **`MemoService.BatchDeleteMemosByTag`** - 专门负责批量删除含特定标签的备忘录
- **`TagService.DeleteTag`** - 专门负责从系统中删除标签本身

#### 2. 语义清晰原则（Semantic Clarity）

- **`RenameMemoTag`** 保持原有 API 设计，仅移除全局操作支持（`parent = "memos/-"`）
- **避免模糊操作**：移除了 `DeleteMemoTag`，因为它的语义不够明确（删除标签还是删除备忘录？）
- **明确操作范围**：通过命名清晰表达操作的影响范围（单个 vs 全局，标签 vs 备忘录）

#### 3. 避免歧义和危险操作

- **分离复合操作**：不在单个 API 中执行语义不明确或具有潜在危险的复合操作
- **明确批量操作**：`BatchDeleteMemosByTag` 明确表达这是批量删除备忘录，而非标签
- **提供安全机制**：支持 `dry_run` 参数预览操作结果

### 开发者使用指南

基于这些设计原则，开发者会清楚地知道：

| 需求 | 应该调用的 API | 职责范围 |
|------|---------------|---------|
| 重命名某个备忘录的标签 | `MemoService.RenameMemoTag` | 单个备忘录 |
| 在整个系统中重命名标签 | `TagService.RenameTag` | 全局标签系统 |
| 批量删除带有某个标签的备忘录 | `MemoService.BatchDeleteMemosByTag` | 批量备忘录操作 |
| 从系统中删除标签 | `TagService.DeleteTag` | 全局标签管理 |

这种设计极大提高了 API 的**可维护性**、**可预测性**和**安全性**。

### 最小修改原则

这次重构遵循**最小修改原则**，最大程度保留原有设计：

1. **保持现有 API 结构**：`RenameMemoTag` 和 `DeleteMemoTag` 的签名和行为保持不变
2. **只移除全局功能**：不再支持 `parent = "memos/-"` 的全局操作
3. **服务端实现调整**：只需要在现有代码中添加参数验证，拒绝 `"memos/-"` 请求
4. **向后兼容**：现有客户端对单个 memo 的调用完全不受影响

## 🔧 新的 API 设计

### TagService (`/proto/api/v1/tag_service.proto`)

```protobuf
service TagService {
  // List all tags with optional filtering
  rpc ListTags(ListTagsRequest) returns (ListTagsResponse) {
    option (google.api.http) = {
      get: "/api/v1/tags"
    };
  }

  // Get specific tag details
  rpc GetTag(GetTagRequest) returns (GetTagResponse) {
    option (google.api.http) = {
      get: "/api/v1/tags/{tag_path=**}"  // ** for path parameters with '/'
    };
    option (google.api.method_signature) = "tag_path";
  }

  // Rename tag globally (supports path moving)
  rpc RenameTag(RenameTagRequest) returns (RenameTagResponse) {
    option (google.api.http) = {
      patch: "/api/v1/tags/{old_tag_path=**}:rename"
      body: "*"
    };
    option (google.api.method_signature) = "old_tag_path,new_tag_path";
  }

  // Delete tag from all content (without deleting memos)
  rpc DeleteTag(DeleteTagRequest) returns (DeleteTagResponse) {
    option (google.api.http) = {
      delete: "/api/v1/tags/{tag_path=**}"
    };
    option (google.api.method_signature) = "tag_path";
  }
}
```

### MemoService 调整

```protobuf
service MemoService {
  // ... 现有的 API ...

  // 🔧 MODIFIED: 保持现有 API，仅移除全局操作支持
  rpc RenameMemoTag(RenameMemoTagRequest) returns (google.protobuf.Empty) {
    option (google.api.http) = {
      patch: "/api/v1/{parent=memos/*}/tags:rename"
      body: "*"
    };
    option (google.api.method_signature) = "parent,old_tag,new_tag";
  }

  // 🔧 MODIFIED: 保持现有 API，仅移除全局操作支持
  rpc DeleteMemoTag(DeleteMemoTagRequest) returns (google.protobuf.Empty) {
    option (google.api.http) = {delete: "/api/v1/{parent=memos/*}/tags/{tag}"};
    option (google.api.method_signature) = "parent,tag";
  }

  // 🚨 NEW: Batch delete memos by tag (using query parameters)
  rpc BatchDeleteMemosByTag(BatchDeleteMemosByTagRequest) returns (BatchDeleteMemosByTagResponse) {
    option (google.api.http) = {
      delete: "/api/v1/memos"  // 查询参数: ?tag_path=...&include_children=...&dry_run=...
    };
    option (google.api.method_signature) = "tag_path";
  }
}
```

## 🌐 RESTful HTTP 映射

### URL 设计原则

1. **路径参数处理**：使用 `{tag_path=**}` 支持路径中的 `/` 字符
2. **URL 编码**：客户端需要对包含 `/` 的标签路径进行编码
   - 例：`/work/project1` → `/api/v1/tags/%2Fwork%2Fproject1`
3. **查询参数**：复杂参数通过查询参数传递，避免 DELETE 请求体兼容性问题

### API 端点映射

| 操作 | HTTP 方法 | URL | 说明 |
|------|-----------|-----|------|
| 列出标签 | GET | `/api/v1/tags?path_prefix=...&include_memo_ids=...` | 支持前缀过滤 |
| 获取标签 | GET | `/api/v1/tags/{encoded_tag_path}?include_memo_ids=true` | 获取单个标签详情 |
| 重命名标签（全局） | PATCH | `/api/v1/tags/{encoded_old_path}:rename` | 全局标签重命名 |
| 删除标签（全局） | DELETE | `/api/v1/tags/{encoded_tag_path}?strategy=...` | 从系统中删除标签 |
| 重命名备忘录标签 | PATCH | `/api/v1/memos/{memo_id}/tags:rename` | 重命名单个备忘录的特定标签 |
| 删除备忘录标签 | DELETE | `/api/v1/memos/{memo_id}/tags/{tag_name}` | 删除单个备忘录的特定标签 |
| 批量删除备忘录 | DELETE | `/api/v1/memos?tag_path=...&include_children=...&dry_run=...` | 删除包含标签的备忘录 |

## 📋 请求/响应消息

### 核心请求消息

```protobuf
message ListTagsRequest {
  // Query parameter: ?path_prefix=/work
  string path_prefix = 1;

  // Query parameter: ?include_memo_ids=true
  // Server default: false if not specified
  bool include_memo_ids = 2;

  // Query parameter: ?include_hierarchy=true
  // Server default: true if not specified
  bool include_hierarchy = 3;
}

message GetTagRequest {
  // Path parameter: /api/v1/tags/{tag_path}
  // URL encoded if contains '/' (e.g., %2Fwork%2Fproject1)
  string tag_path = 1 [(google.api.field_behavior) = REQUIRED];

  // Query parameter: ?include_memo_ids=true
  // Server default: true if not specified
  bool include_memo_ids = 2;
}

message RenameTagRequest {
  // Path parameter: /api/v1/tags/{old_tag_path}:rename
  string old_tag_path = 1 [(google.api.field_behavior) = REQUIRED];

  // Request body field
  string new_tag_path = 2 [(google.api.field_behavior) = REQUIRED];

  // Request body field - Server default: true if not specified
  bool move_children = 3;
}

message DeleteTagRequest {
  // Path parameter: /api/v1/tags/{tag_path}
  string tag_path = 1 [(google.api.field_behavior) = REQUIRED];

  enum DeleteStrategy {
    REMOVE_FROM_CONTENT = 0;  // Remove tag from all memo content
    DELETE_RELATED_MEMOS = 1; // Delete memos containing this tag
  }

  // Query parameter: ?strategy=REMOVE_FROM_CONTENT
  // Server default: REMOVE_FROM_CONTENT if not specified
  DeleteStrategy strategy = 2;
}

// 🔧 MODIFIED: 现有消息保持不变，仅文档更新
message RenameMemoTagRequest {
  // Required. The parent, who owns the tags.
  // Format: memos/{memo_id} (不再支持 "memos/-")
  string parent = 1 [(google.api.field_behavior) = REQUIRED];

  // Required. The old tag name to rename.
  string old_tag = 2 [(google.api.field_behavior) = REQUIRED];

  // Required. The new tag name.
  string new_tag = 3 [(google.api.field_behavior) = REQUIRED];
}

message DeleteMemoTagRequest {
  // Required. The parent, who owns the tags.
  // Format: memos/{memo_id} (不再支持 "memos/-")
  string parent = 1 [(google.api.field_behavior) = REQUIRED];

  // Required. The tag name to delete.
  string tag = 2 [(google.api.field_behavior) = REQUIRED];
}

message BatchDeleteMemosByTagRequest {
  // Query parameter: ?tag_path=/work/project1
  string tag_path = 1 [(google.api.field_behavior) = REQUIRED];

  // Query parameter: ?include_children=true
  // Server default: true if not specified
  bool include_children = 2;

  // Query parameter: ?dry_run=true
  // Server default: false if not specified
  bool dry_run = 3;
}
```

### 统一的响应结构

```protobuf
message TagWithMemos {
  memos.store.TagNode tag_node = 1;

  // Direct memo count (excluding child tags)
  int32 direct_memo_count = 2;

  // Total memo count (including child tags)
  int32 total_memo_count = 3;

  // Child tag paths
  repeated string child_paths = 4;

  // Parent tag path
  string parent_path = 5;
}

message ListTagsResponse {
  repeated TagWithMemos tags = 1;
  int32 total_count = 2;
}

message GetTagResponse {
  TagWithMemos tag = 1;
}

message RenameTagResponse {
  // Affected memo IDs
  repeated string affected_memo_ids = 1;

  // Old and new tag paths that were changed
  map<string, string> renamed_paths = 2; // old_path -> new_path
}

message DeleteTagResponse {
  // Memo IDs that had this tag removed
  repeated string affected_memo_ids = 1;

  // Tag paths that were deleted
  repeated string deleted_tag_paths = 2;
}

message BatchDeleteMemosByTagResponse {
  repeated string deleted_memo_ids = 1;
  int32 deleted_count = 2;
  repeated string affected_tag_paths = 3;
}
```

## 🔄 数据流和生命周期

### Tag 生命周期管理

1. **创建**：memo 内容解析时自动创建 TagNode 并填充 memo_ids
2. **更新**：memo 内容变更时，更新相关 TagNode 的 memo_ids
3. **删除**：memo_ids 为空的 TagNode 自动清理

### 层级查询逻辑

```sql
-- 查找所有 /work 相关的标签（包括子标签）
SELECT * FROM tag_nodes WHERE name LIKE '/work%'

-- 查找所有使用 /work 标签的 memos（包括子标签的 memos）
SELECT DISTINCT memo_id FROM tag_nodes
WHERE name LIKE '/work%'
AND memo_id IN (SELECT unnest(memo_ids))
```

### 重命名操作流程

1. **验证**：检查新路径是否已存在
2. **收集**：获取所有需要重命名的标签路径（包括子标签）
3. **更新**：在事务中更新所有相关的 memo 内容和 TagNode 记录
4. **返回**：返回所有受影响的 memo_ids 和路径映射

## ⚠️ 实施注意事项

### 服务端默认值处理

由于 protobuf 中的默认值注释只是文档，服务端需要显式处理：

```go
// 伪代码示例
func (s *TagService) ListTags(ctx context.Context, req *ListTagsRequest) (*ListTagsResponse, error) {
    // 处理默认值
    if !req.HasIncludeHierarchy() {
        req.IncludeHierarchy = true  // 服务端默认值
    }
    // ... 业务逻辑
}
```

### URL 编码处理

客户端需要正确处理包含 `/` 的标签路径：

```javascript
// 前端示例
const tagPath = "/work/project1";
const encodedPath = encodeURIComponent(tagPath); // %2Fwork%2Fproject1
const url = `/api/v1/tags/${encodedPath}`;
```

### 事务一致性

标签操作涉及多个数据的更新，需要确保事务一致性：

1. **memo 内容更新**和**TagNode.memo_ids 更新**必须在同一事务中
2. **重命名操作**涉及多个 TagNode 和 memo 记录，需要适当的锁机制
3. **批量删除**操作需要考虑并发安全
